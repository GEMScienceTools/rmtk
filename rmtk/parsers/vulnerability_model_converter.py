#!/usr/bin/env python
# LICENSE
#
# Copyright (c) 2014, GEM Foundation, Anirudh Rao
#
# The rmtk is free software: you can redistribute
# it and/or modify it under the terms of the GNU Affero General Public
# License as published by the Free Software Foundation, either version
# 3 of the License, or (at your option) any later version.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake. If not, see <http://www.gnu.org/licenses/>
#
# DISCLAIMER
#
# The software rmtk provided herein is released as a prototype
# implementation on behalf of scientists and engineers working within the GEM
# Foundation (Global Earthquake Model).
#
# It is distributed for the purpose of open collaboration and in the
# hope that it will be useful to the scientific, engineering, disaster
# risk and software design communities.
#
# The software is NOT distributed as part of GEM's OpenQuake suite
# (http://www.globalquakemodel.org/openquake) and must be considered as a
# separate entity. The software provided herein is designed and implemented
# by scientific staff. It is not developed to the design standards, nor
# subject to same level of critical review by professional software
# developers, as GEM's OpenQuake software suite.
#
# Feedback and contribution to the software is welcome, and can be
# directed to the risk scientific staff of the GEM Model Facility
# (risk@globalquakemodel.org).
#
# The nrml_converters is therefore distributed WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License for more details.
#
# The GEM Foundation, and the authors of the software, assume no liability for
# use of the software.
"""
Convert vulnerability model csv files to xml.
"""

import os
import ConfigParser
import argparse
import pandas as pd
import numpy as np
from lxml import etree
import matplotlib.pyplot as plt

NAMESPACE = 'http://openquake.org/xmlns/nrml/0.5'
GML_NAMESPACE = 'http://www.opengis.net/gml'
SERIALIZE_NS_MAP = {None: NAMESPACE, 'gml': GML_NAMESPACE}


def csv_to_xml(metadata_txt, output_xml):
    """
    Converts the CSV vulnerability model file to the NRML format
    """

    conf = ConfigParser.ConfigParser()
    conf.read(metadata_txt)
    metadata = conf._sections

    metadata['main']['path'] = os.path.abspath(
        os.path.join(os.path.abspath(metadata_txt),
                     os.pardir,
                     metadata['main']['path']))

    taxonomy_list = metadata.keys()
    taxonomy_list.remove('main')

    with open(output_xml, "w") as f:
        root = etree.Element('nrml', nsmap=SERIALIZE_NS_MAP)
        node_fm = etree.SubElement(root, "vulnerabilityModel")
        node_fm.set("id", metadata['main']['id'])
        node_fm.set("assetCategory", metadata['main']['asset_category'])
        node_fm.set("lossCategory", metadata['main']['loss_category'])

        node_desc = etree.SubElement(node_fm, "description")
        node_desc.text = metadata['main']['description']

        for taxonomy in taxonomy_list:

            node_ffs = etree.SubElement(node_fm, "vulnerabilityFunction")
            node_ffs.set("id", taxonomy)
            node_ffs.set("dist", metadata[taxonomy]['dist'])
            node_imls = etree.SubElement(node_ffs, "imls")
            imt = metadata[taxonomy]['imt']
            node_imls.set("imt", imt)

            conf.set(taxonomy, 'path', metadata['main']['path'])
            vul_file = conf.get(taxonomy, 'file')

            if metadata[taxonomy]['dist'] in 'PM':
                vul_data = pd.read_csv(vul_file, index_col=0)
                node_imls.text = ' '.join([str(x) for x in vul_data.index])

                for line in vul_data.iteritems():
                    node_prob = etree.SubElement(node_ffs, "probabilites")
                    node_prob.set("lr", line[0])
                    node_prob.text = " ".join(map(str, line[1].values))

            elif metadata[taxonomy]['dist'] in ['LN', 'BT']:
                vul_data = pd.read_csv(vul_file)
                node_imls.text = ' '.join([str(x) for x in vul_data[imt]])

                node_mean = etree.SubElement(node_ffs, "meanLRs")
                node_mean.text = " ".join(map(str, vul_data['meanLRs'].values))
                node_cov = etree.SubElement(node_ffs, "covLRs")
                node_cov.text = " ".join(map(str, vul_data['covLRs'].values))

        f.write(etree.tostring(root, pretty_print=True, xml_declaration=True, encoding='UTF-8'))


def xml_to_csv (input_xml, output_csv):
    """
    Converts the XML vulnerability model file to the CSV format
    """
    print('This feature will be implemented in a future release.')


class VulnerabilityModel(object):
    '''
    class for a Vulnerability model which is a collection of Vulnerability functions
    '''

    def parse_xml(self, input_file=None):

        if not os.path.exists(input_file):
            print('file {} not found'.format(input_file))
            sys.exit(1)

        self.input_file = input_file

        for _, element in etree.iterparse(input_file):

            if 'Model' in element.tag:

                self.metadata = dict()
                self.metadata['asset_category'] = element.attrib['assetCategory']
                self.metadata['id'] = element.attrib['id']
                self.metadata['loss_category'] = element.attrib['lossCategory']

                self.vul = dict()
                for item in element.getchildren():

                    if 'description' in item.tag:
                        self.metadata['description'] = item.text.strip()
                    elif 'Function' in item.tag:
                        taxonomy = item.attrib['id']
                        self.vul[taxonomy] = VulnerabilityFunction(item, self.metadata)

    def plot_vulnerability(self, im_range):
        for bldg, bldg_vul in self.vul.iteritems():
            bldg_vul.plot_Vulnerability(im_range)

class VulnerabilityFunction(object):

    def __init__(self, element, metadata):

        self.metadata = metadata
        self.taxonomy = element.attrib['id']
        self.dist = element.attrib['dist']
        children = element.getchildren()

        if self.dist in ['LN', 'BT']:
            self.distVulnerabilityModelParser(children)
        else:
            self.probVulnerabilityModelParser(children)

    def plot_vulnerability(self, im_range):

        self.compute_loss_ratios(im_range)

        if self.dist in ['LN', 'BT']:
            plt.figure()
            plt.errorbar(im_range, self.est_mean, yerr=self.est_sigma)
            plt.grid(1)
            plt.xlabel(self.imt)
            plt.ylabel('Loss Ratio')
            plt.title(self.taxonomy)
        else:
            print 'Not implemented yet'

    def compute_loss_ratios(self, im_range):

        if self.dist in ['LN', 'BT']:
            self.est_mean = np.interp(im_range, self.iml, self.meanLRS, left=0.0)
            self.est_mean[self.est_mean > 1]= 1.0
            est_cov = np.interp(im_range, self.iml, self.covLRS)
            self.est_sigma = self.est_mean*est_cov
        else:
            print 'Not implemented yet'
            self.est_mean = None
            self.est_sigma = None

    def distVulnerabilityModelParser(self, children):

        for item in children:

            if 'imls' in item.tag:
                self.imt = item.attrib['imt']
                self.iml = [float(x) for x in item.text.split()]
            elif 'mean' in item.tag:
                self.meanLRS = [float(x) for x in item.text.split()]
            elif 'cov' in item.tag:
                self.covLRS = [float(x) for x in item.text.split()]

    def probVulnerabilityModelParser(self, children):

        for item in children:

            if 'imls' in item.tag:
                self.imt = item.attrib['imt']

            elif 'probabilities' in item.tag:
                loss_ratio = item.attrib['lr']
                self.prob[loss_ratio] = [float(x) for x in item.text.split()]



def set_up_arg_parser():
    """
    Can run as executable. To do so, set up the command line parser
    """

    description = ('Convert a Vulnerability Model from CSV to XML and '
                   'vice versa.\n\nTo convert from CSV to XML: '
                   '\npython vulnerability_model_converter.py '
                   '--metadata-txt-file PATH_TO_VULNERABILITY_METADATA_TXT_FILE '
                   '--output-xml-file PATH_TO_OUTPUT_XML_FILE'
                   '\n\nTo convert from XML to CSV type: '
                   '\npython vulnerability_model_converter.py '
                   '--input-xml-file PATH_TO_VULNERABILITY_MODEL_XML_FILE '
                   '--output-csv-file PATH_TO_OUTPUT_CSV_FILE')

    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawTextHelpFormatter)
    flags = parser.add_argument_group('flag arguments')

    group_input = flags.add_mutually_exclusive_group(required=True)

    group_input.add_argument('--metadata-txt-file',
                             help='path to vulnerability metadata TXT file',
                             default=None)
    group_input.add_argument('--input-csv-file',
                             help='path to vulnerability model CSV file',
                             default=None)

    group_output = flags.add_mutually_exclusive_group()
    group_output.add_argument('--output-xml-file',
                              help='path to output XML file',
                              default=None)
    group_output.add_argument('--output-csv-file',
                              help='path to output CSV file',
                              default=None,
                              required=False)
    return parser


if __name__ == "__main__":

    parser = set_up_arg_parser()
    args = parser.parse_args()
    if args.metadata_txt_file:
        csv_to_xml(args.metadata_txt_file, args.output_xml_file)
    elif args.input_xml_file:
        if args.output_csv_file:
            output_file = args.output_csv_file
        else:
            (filename, ext) = os.path.splitext(args.input_xml_file)
            output_file = filename + '.csv'
        xml_to_csv(args.input_xml_file, output_file)
    else:
        parser.print_usage()
