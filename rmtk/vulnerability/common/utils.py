# -*- coding: utf-8 -*-
import os
import numpy
from scipy import stats
import math
import csv
from scipy import interpolate
from scipy import optimize
import matplotlib.pyplot as plt
from scipy.integrate import cumtrapz
from shapely.geometry import (LineString,MultiPoint,Point)
from scipy.stats import lognorm

def read_capacity_curves(input_file):
    # This function reads one, or a set of capacity curves 
       
    file=open(input_file)
    data=csv.reader(file)
    for line in data:
        if line[0] == 'Vb-droof' and line[1] == 'TRUE':
            capacity_curves = read_Vbdroof_capacity_curves(data)
            break
        elif line[0] == 'Vb-dfloor' and line[1] == 'TRUE':
            capacity_curves = read_Vbdfloor_capacity_curves(data)
            break
        elif line[0] == 'Sd-Sa' and line[1] == 'TRUE':
            capacity_curves = read_SdSa_capacity_curves(data)
            break

    return capacity_curves
    
def read_Vbdfloor_capacity_curves(data):
    
    # This function reads Sd-Sa type of capacity curves
    periods = []
    ground_heights = []
    regular_heights = []
    gammas = []
    no_storeys = []
    Vb = []
    d_floor = []
    d_roof = []
    id_floor = []
    
    for line in data:
        if line[0] == 'Periods [s]':
            for value in line[1:]:
                if isNumber(value):
                    periods.append(float(value))
        if line[0] == 'Ground heights [m]':
            for value in line[1:]:
                if isNumber(value):
                    ground_heights.append(float(value))
        if line[0] == 'Regular heights [m]':
            for value in line[1:]:
                if isNumber(value):
                    regular_heights.append(float(value))                
        if line[0] == 'Gamma participation factors':
            for value in line[1:]:
                if isNumber(value):
                    gammas.append(float(value))
        if line[0] == 'Number storeys':
            for value in line[1:]:
                if isNumber(value):
                    no_storeys.append(float(value))
        if line[0][0:6] == 'dfloor':
            subd_floor = []
            for value in line[1:]:
                if isNumber(value):
                    subd_floor.append(float(value))
            id_floor.append(subd_floor)
            if len(id_floor) == no_storeys[-1]:
                d_floor.append(id_floor)
                d_roof.append(subd_floor)
                id_floor = []
        if line[0][0:2] == 'Vb' and isNumber(line[0][2]):
            subVb = []
            for value in line[1:]:
                if isNumber(value):
                    subVb.append(float(value))
            Vb.append(subVb)

    # Store all the data in the dictionary
    capacity_curves = {'type': None, 'periods': None, 'ground_heights': None, 
        'regular_heights': None, 'gamma': None, 'no_storeys': None, 'dfloor': None, 
        'droof': None, 'Vb': None}

    capacity_curves['type'] = 'Vb-dfloor'
    capacity_curves['periods'] = periods
    capacity_curves['ground_heights'] = ground_heights
    capacity_curves['regular_heights'] = regular_heights
    capacity_curves['gamma'] = gammas
    capacity_curves['no_storeys'] = no_storeys
    capacity_curves['dfloor'] = d_floor
    capacity_curves['droof'] =  d_roof  
    capacity_curves['Vb'] = Vb
    
    return capacity_curves
    
def read_Vbdroof_capacity_curves(data):
    
    # This function reads Sd-Sa type of capacity curves
    periods = []
    ground_heights = []
    regular_heights = []
    gammas = []
    no_storeys = []
    Vb = []
    d_roof = []
    
    for line in data:
        if line[0] == 'Periods [s]':
            for value in line[1:]:
                if isNumber(value):
                    periods.append(float(value))
        if line[0] == 'Ground heights [m]':
            for value in line[1:]:
                if isNumber(value):
                    ground_heights.append(float(value))
        if line[0] == 'Regular heights [m]':
            for value in line[1:]:
                if isNumber(value):
                    regular_heights.append(float(value))                
        if line[0] == 'Gamma participation factors':
            for value in line[1:]:
                if isNumber(value):
                    gammas.append(float(value))
        if line[0] == 'Number storeys':
            for value in line[1:]:
                if isNumber(value):
                    no_storeys.append(float(value))
        if line[0][0:5] == 'droof':
            subd_roof = []
            for value in line[1:]:
                if isNumber(value):
                    subd_roof.append(float(value))
            d_roof.append(subd_roof)
        if line[0][0:2] == 'Vb' and isNumber(line[0][2]):
            subVb = []
            for value in line[1:]:
                if isNumber(value):
                    subVb.append(float(value))
            Vb.append(subVb)

    # Store all the data in the dictionary
    capacity_curves = {'type': None, 'periods': None, 'ground_heights': None, 
        'regular_heights': None, 'gamma': None, 'no_storeys': None, 'droof': None, 
        'Vb': None}

    capacity_curves['type'] = 'Vb-droof'
    capacity_curves['periods'] = periods
    capacity_curves['ground_heights'] = ground_heights
    capacity_curves['regular_heights'] = regular_heights
    capacity_curves['gamma'] = gammas
    capacity_curves['no_storeys'] = no_storeys
    capacity_curves['droof'] =  d_roof  
    capacity_curves['Vb'] = Vb
    
    return capacity_curves
    
def read_SdSa_capacity_curves(data):

    # This function reads Sd-Sa type of capacity curves
    periods = []
    heights = []
    gammas = []
    Sdy = []
    Say = []
    Sd = []
    Sa = []
    
    for line in data:
        if line[0] == 'Periods [s]':
            for value in line[1:]:
                if isNumber(value):
                    periods.append(float(value))
        if line[0] == 'Heights [m]':
            for value in line[1:]:
                if isNumber(value):
                    heights.append(float(value))
        if line[0] == 'Gamma participation factors':
            for value in line[1:]:
                if isNumber(value):
                    gammas.append(float(value))
        if line[0] == 'Sdy [m]':
            for value in line[1:]:
                if isNumber(value):
                    Sdy.append(float(value))
        if line[0] == 'Say [g]':
            for value in line[1:]:
                if isNumber(value):
                    Say.append(float(value))
        if line[0][0:2] == 'Sd' and isNumber(line[0][2]):
            subSd = []
            for value in line[1:]:
                if isNumber(value):
                    subSd.append(float(value))
            Sd.append(subSd)
        if line[0][0:2] == 'Sa' and isNumber(line[0][2]):
            subSa = []
            for value in line[1:]:
                if isNumber(value):
                    subSa.append(float(value))
            Sa.append(subSa)

    # Store all the data in the dictionary
    capacity_curves = {'type': None, 'periods': None, 'heights': None, 
        'gamma': None, 'Sdy': None, 'Say': None, 'Sd': None, 'Sa': None}

    capacity_curves['type'] = 'Sd-Sa'
    capacity_curves['periods'] = periods
    capacity_curves['heights'] = heights
    capacity_curves['gamma'] = gammas
    capacity_curves['Sdy'] = Sdy
    capacity_curves['Say'] = Say
    capacity_curves['Sd'] = Sd
    capacity_curves['Sa'] = Sa
        
    return capacity_curves
    
def save_capacity_curves(capacity_curves,filename):
    
    if capacity_curves['type'] == 'Sd-Sa':
        save_SdSa_capacity_curves(capacity_curves,filename)
        
def save_SdSa_capacity_curves(capacity_curves,filename):
    
    no_capacity_curves = len(capacity_curves['Sd'])
    output = open(filename,'w')
    output.write('Vb-droof,FALSE\n')
    output.write('Vb-dfloor,FALSE\n')
    output.write('Sd-Sa,TRUE\n')
    periods = 'Periods [s]'
    heights = 'Heights [m]'
    gammas = 'Gamma participation factors'
    Sdy = 'Sdy [m]'
    Say = 'Say [g]'
    for icc in range(no_capacity_curves):
        if capacity_curves['periods'] != None:
            periods = periods + ',' + str(capacity_curves['periods'][icc])
        if capacity_curves['heights'] != None:
            heights = heights + ',' + str(capacity_curves['heights'][icc])
        if capacity_curves['gamma'] != None:
            gammas = gammas + ',' + str(capacity_curves['gamma'][icc])
        if capacity_curves['Sdy'] != None:
            Sdy = Sdy + ',' + str(capacity_curves['Sdy'][icc])
        if capacity_curves['Say'] != None:
            Say = Say + ',' + str(capacity_curves['Say'][icc])
    
    output.write(periods + '\n')
    output.write(heights + '\n')
    output.write(gammas + '\n')
    output.write(Sdy + '\n')
    output.write(Say + '\n')
    
    for icc in range(no_capacity_curves):
        Sd = 'Sd'+str(icc+1)+' [m]'
        Sa = 'Sa'+str(icc+1)+' [g]'
        for ivalue in range(len(capacity_curves['Sd'][icc])):
            Sd = Sd + ',' + str(capacity_curves['Sd'][icc][ivalue])
            Sa = Sa + ',' + str(capacity_curves['Sa'][icc][ivalue])
        output.write(Sd + '\n')
        output.write(Sa + '\n')

    output.close()
    
def plot_capacity_curves(capacity_curves):
    
    #This function plots the capacity curves
    if capacity_curves['type'] == 'Sd-Sa':
        no_capacity_curves = len(capacity_curves['Sa'])
        for icc in range(no_capacity_curves):
            Sa = capacity_curves['Sa'][icc]
            Sd = capacity_curves['Sd'][icc]
            plt.plot(Sd,Sa,color='g',linewidth=2)
        plt.plot(Sd,Sa,color='g',linewidth=2,label='individual capacity curve')
        plt.xlabel('Spectral displacement [m]',fontsize = 10)
        plt.ylabel('Spectral acceleration [g]',fontsize = 10)
    
    elif capacity_curves['type'] == 'Vb-dfloor' or capacity_curves['type'] == 'Vb-droof':
        no_capacity_curves = len(capacity_curves['Vb'])
        for icc in range(no_capacity_curves):
            Vb = capacity_curves['Vb'][icc]
            droof = capacity_curves['droof'][icc]
            plt.plot(droof,Vb,color='g',linewidth=2)
        plt.plot(droof,Vb,color='g',linewidth=2,label='individual capacity curve')
        plt.xlabel('Roof displacement [m]',fontsize = 10)
        plt.ylabel('Base shear [kN]',fontsize = 10)
    
    plt.suptitle('Capacity curves')
    plt.legend(loc='lower right',frameon = False)
    plt.show()
    
def read_gmrs(folder):
    
    #This function reads a set of ground motion records
    #and stores them in a dictionary
    time = []
    acc = []
    dt = []
    no_points = []
    name = []
    for file in os.listdir(folder):
        if file.endswith(".csv"):
            itime, iacc = read_gmr(folder,file)
            time.append(itime)
            acc.append(iacc)
            dt.append(itime[1] - itime[0])
            no_points.append(len(iacc))
            name.append(file)          
    gmrs = {'time': None, 'acc': None, 'dt': None,
        'no_points': None, 'name': None}
    gmrs['time'] = time  
    gmrs['acc'] = acc  
    gmrs['dt'] = dt
    gmrs['no_points'] = no_points
    gmrs['name'] = name
    
    return gmrs       
            
def read_gmr(folder,gmr):
    
    file=open(folder+'/'+gmr)
    lines=file.readlines()
    time = []
    acc = []
    for line in lines:
        line = line.split(',')
        time.append(float(line[0]))
        acc.append(float(line[1])*9.81)   
        
    return time, acc
    
def plot_response_spectra(gmrs,minT,maxT):
    
    no_gmrs = len(gmrs['time'])
    damping = 0.05
    T = numpy.linspace(minT,maxT,50)
    plt.figure(figsize=(15,5))
    for igmr in range(no_gmrs):
        acc = gmrs['acc'][igmr]
        time = gmrs['time'][igmr]
        spectrum = NigamJennings(time,acc,T,damping)
    #    spectrum = NewmarkBeta(time,acc,T,damping)
     
        plt.subplot(1, 3, 1)
        plt.plot(T,spectrum['Sa'],color='g',linewidth=2)
        plt.subplot(1, 3, 2)
        plt.plot(T,spectrum['Sd'],color='g',linewidth=2)
        plt.subplot(1, 3, 3)
        plt.plot(spectrum['Sd'],spectrum['Sa'],color='g',linewidth=2)
    
    plt.subplot(1, 3, 1)
    plt.xlabel('Periods of vibration (sec)',fontsize = 10)
    plt.ylabel('Spectral acceleration (g)',fontsize = 10)
    plt.subplot(1, 3, 2)
    plt.xlabel('Periods of vibration (sec)',fontsize = 10)
    plt.ylabel('Spectral displacement (m)',fontsize = 10)
    plt.subplot(1, 3, 3)
    plt.xlabel('Spectral displacement (m)',fontsize = 10)
    plt.ylabel('Spectral acceleration (g)',fontsize = 10)
    plt.show()
    
def NewmarkBeta(time,acc,T,damping):
	
    u0 = 0
    v0 = 0
    dt = time[1]-time[0]   
    no_acc = len(acc)
    no_T = len(T)
    M = 1
    Sd = numpy.zeros(no_T)
    Sa = numpy.zeros(no_T)
    u = numpy.zeros(no_acc)
    a = numpy.zeros(no_acc)
    v = numpy.zeros(no_acc)
    at = numpy.zeros(no_acc)
    
    for i in range(no_T):
        if T[i] == 0:
            Sd[i] = 0
            Sa[i] = max(abs(numpy.array(acc)))
        else:
            wn = 2*math.pi/T[i]
            C = damping*2*M*wn
            K = ((2*math.pi)/T[i])**2*M
            u[0] = u0                                    
            v[0] = v0
            a[0] = -acc[0]-C*v[0]-K*u[0]
            at[0] = acc[0]+a[0]
            for j in range(no_acc-1):
                u[j+1] = u[j]+dt*v[j]+dt**2/2*a[j]
                a[j+1] = (1/(M+dt*0.5*C))*(-M*acc[j+1]-K*u[j+1]-C*(v[j]+dt*0.5*a[j]))
                v[j+1] = v[j]+dt*(0.5*a[j]+0.5*a[j+1])
                at[j+1] = acc[j+1]+a[j+1]
            
            Sd[i]=max(abs(u))
            Sa[i]=max(abs(at))/9.81
 
    spectrum = {'Sd': None, 'Sa': None}
    spectrum['Sd'] = Sd  
    spectrum['Sa'] = Sa      
    
    return spectrum
    
def isNumber(s):
    try: 
        float(s)
        return True
    except ValueError:
        return False
        
def read_damage_model(input_file):
    
    damage_states = []
    type_damage_state = []
    distribution = []
    mean = []
    cov = []
    file=open(input_file)
    data=file.readlines()
    line = data[0]
    line = line.strip().split(',')
    type_criteria = line[1]
    
    for iline in range(len(data)-2):
        line = data[iline+2]
        line = line.strip().split(',')
        damage_states.append(line[0])
        type_damage_state.append(line[1])
        distribution.append(line[2])
        if type_criteria == 'capacity curve dependent':
            if isNumber(line[3]):
                mean.append(float(line[3]))
            else:
                mean.append(line[4])
            cov.append(float(line[4]))
            
        if type_criteria == 'strain dependent':
            mean.append(extract_values_string(line[3]))
            cov.append(extract_values_string(line[4]))
                        
    damage_model = {'type_criteria': None, 'damage_states': None,
        'type_damage_state': None, 'mean': None, 'cov': None}
    damage_model['type_criteria'] = type_criteria  
    damage_model['damage_states'] = damage_states  
    damage_model['type_damage_state'] = type_damage_state  
    damage_model['distribution'] = distribution  
    damage_model['mean'] = mean  
    damage_model['cov'] = cov
    
    return damage_model
    
def extract_values_string(string):
    
    string = string.split(' ')
    values = []
    if isNumber(string[0]):
        for value in string:
            values.append(float(value))
            
    return values
    
def define_limit_states(capacity_curves,icc,damage_model):

    no_damage_states = len(damage_model['damage_states'])
    limit_states = []
    if damage_model['type_criteria'] == 'capacity curve dependent':
        Sd = capacity_curves['Sd'][icc]
        Sa = capacity_curves['Sa'][icc]
        Sdy = capacity_curves['Sdy'][icc]
        Say = capacity_curves['Say'][icc] 
        for ids in range(no_damage_states):
            type_damage_state = damage_model['type_damage_state'][ids]
            distribution = damage_model['distribution'][ids]
            mean = damage_model['mean'][ids]
            cov = damage_model['cov'][ids]
            limit_states.append(define_limit_state(Sd,Sa,Sdy,Say,type_damage_state,distribution,mean,cov))
    
    return limit_states
    
def define_limit_state(Sd,Sa,Sdy,Say,type_damage_state,distribution,mean,cov):

    if type_damage_state == 'Sdy':
        mean = Sdy
        limit_state = sample_limit_state(distribution,mean,cov)
        
    elif type_damage_state == 'Sdu':     
        mean = max(Sd)
        limit_state = sample_limit_state(distribution,mean,cov)

    elif type_damage_state == 'fraction Sdy':
        mean = mean*Sdy
        limit_state = sample_limit_state(distribution,mean,cov)
        
    elif type_damage_state == 'mean Sdy Sdu':
        mean = (Sdy+max(Sd))/2
        limit_state = sample_limit_state(distribution,mean,cov)
    elif isNumber(type_damage_state[0]):
        values = type_damage_state.split()
        weight1 = float(values[0])
        weight2 = float(values[2])
        mean = (weight1*Sdy + weight2*max(Sd))/(weight1+weight2)
        limit_state = sample_limit_state(distribution,mean,cov)
        
    return limit_state
    
def sample_limit_state(distribution,mean,cov):
    
    if cov == 0:
        sampled_limit_state = mean
    else:
        if distribution == 'normal':
            sampled_limit_state = stats.norm.rvs(mean,mean*cov)
        elif distribution == 'lognormal':
            variance = (mean*cov)**2.0
            mu = math.log(mean ** 2.0 / math.sqrt(variance + mean ** 2.0) )
            sigma = math.sqrt(math.log((variance / mean ** 2.0) + 1.0))
            sampled_limit_state = stats.lognorm.rvs(sigma,scale=scipy.exp(mu))
        elif distribution == 'gamma':
            beta = (mean*cov)**2/mean
            alpha = mean/beta
            sampled_limit_state = stats.gamma.rvs(alpha,scale = beta)
            
    return sampled_limit_state
 
def find_intersection(list1,list2,plot_flag):
        
    line1 = []
    for i in range(len(list1[0])):
        line1.append([list1[0][i],list1[1][i]])
    
    line2 = []
    for i in range(len(list2[0])):
        line2.append([list2[0][i],list2[1][i]]) 
            
    curve1 = LineString(line1)
    curve2 = LineString(line2)
    intersection = curve1.intersection(curve2)

    Sdi = []
    Sai = []
    if not intersection.is_empty:
        if isinstance(intersection,Point):
            Sdi.append(intersection.x)
            Sai.append(intersection.y)
        elif isinstance(intersection,MultiPoint):
            for points in intersection:
                coords = points.coords
                for xy in coords:
                    Sdi.append(xy[0])
                    Sai.append(xy[1])
                
        if plot_flag:
            plt.plot(list1[0],list1[1],color='r',linewidth=2)
            plt.plot(list2[0],list2[1],color='b',linewidth=2)
            plt.xlabel('Spectral displacement',fontsize = 10)
            plt.ylabel('Spectral acceleration',fontsize = 10)
            plt.plot(Sdi,Sai, 'ro',color='y')
            plt.show()       
        
    return Sdi,Sai
    
def spread(array,no_steps):
    
    result = numpy.zeros((len(array)-1)*no_steps+1)
    
    for i in range(len(array)-1):
        result[i*no_steps]=array[i]
        step = (array[i+1]-array[i])/no_steps
        for j in range(no_steps):
            result[i*no_steps+j+1]=array[i]+(j+1)*step
            
    result[-1]=array[-1]

    return result
    
def allocate_damage(igmr,PDM,disp,limitStates):
    
    no_ls = len(limitStates)
    PDM[igmr,0]=PDM[igmr,0]+1
    for ils in range(no_ls):
        if disp > limitStates[no_ls-ils-1]:
            PDM[igmr,no_ls-ils]=PDM[igmr,no_ls-ils]+1
            PDM[igmr,0]=PDM[igmr,0]-1
            break
    
    return PDM
    
def residuals(coeffs,y,x):
	
	res = y - stats.lognorm.cdf(IMLs, coeffs[1], scale=scipy.exp(coeffs[0]))
    
	return res
    
def calculate_imls(gmrs,T,damping):
    
    Sa = []
    Sd = []
    pga = []
    for igmr in range(len(gmrs['time'])):
        time = gmrs['time'][igmr]
        acc = gmrs['acc'][igmr]
        spectrum = NigamJennings(time,acc,[T],damping)
        Sa.append(spectrum['Sa'][0])
        Sd.append(spectrum['Sd'][0])
        pga.append(max(abs(numpy.array(acc))))
    
    return Sa,Sd,pga
    
def calculate_mean_fragility(gmrs,PDM,T,damping,IMT,damage_model):
    
    imls = calculate_imls(gmrs,T,damping)
    
    if IMT == 'Sa':
        imls = imls[0]
    elif IMT == 'Sd':
        imls = imls[1]
    elif IMT == 'PGA': 
        imls = imls[2]
        
    no_assets = numpy.sum(PDM,axis=1,dtype = float)
    cumPDM = numpy.fliplr(numpy.cumsum(numpy.fliplr(PDM),axis=1))
    cumPDM = numpy.transpose(cumPDM)
    cumPDM = cumPDM/no_assets

    fragility_model = []
    for iDS in range(len(damage_model['damage_states'])):
        solution, flag = optimize.leastsq(residual_lognormal_dist, [0.1, 0.6], args=(imls, cumPDM[iDS+1]))
        fragility_model.append([solution,damage_model['damage_states'][iDS]])
        
    return fragility_model
    
def plot_fragility_model(fragility_model,minIML,maxIML,save):
    
    imls = numpy.linspace(minIML,maxIML,100)
    for iDS in range(len(fragility_model)): 
        mu = fragility_model[iDS][0][0]
        sigma = fragility_model[iDS][0][1]
        if fragility_model[iDS][1]=='Slight':
            plt.plot(imls,lognorm.cdf(imls, sigma, scale=math.exp(mu)),color='g',linewidth=2,label=fragility_model[iDS][1])
            plt.legend(loc=4)
        elif fragility_model[iDS][1]=='Moderate':
            plt.plot(imls,lognorm.cdf(imls, sigma, scale=math.exp(mu)),color='y',linewidth=2,label=fragility_model[iDS][1])
            plt.legend(loc=4)
        elif fragility_model[iDS][1]=='Extensive':
            plt.plot(imls,lognorm.cdf(imls, sigma, scale=math.exp(mu)),color='orangered',linewidth=2,label=fragility_model[iDS][1])
            plt.legend(loc=4)
        elif fragility_model[iDS][1]=='Collapse':
            plt.plot(imls,lognorm.cdf(imls, sigma, scale=math.exp(mu)),color='r',linewidth=2,label=fragility_model[iDS][1])
            plt.legend(loc=4)
        else:
            plt.plot(imls,lognorm.cdf(imls, sigma, scale=math.exp(mu)),color='g',linewidth=2,label=fragility_model[iDS][1])
            plt.legend(loc=4)
    if save:
        path = 'OutFiles'
        os.makedirs(path)
        out1 = 'Frag_model.png'
        plt.savefig(os.path.join(path,out1))
    plt.show()
    

def create_fragility_out_files(fragility_model,save):
    if save:
        path = 'OutFiles'
        out2 = 'Fragility_output.csv'
        out_file = open(os.path.join(path,out2),'w')
        for iDS in range(len(fragility_model)):
            out_file.write('%f, %f \n' %(fragility_model[iDS][0][0],fragility_model[iDS][0][1]))
        out_file.close()        
    
def NigamJennings(time,acc,periods,damping):

    dt = time[1]-time[0]   
    num_steps = len(acc)
    num_per = len(periods)
    velocity, ddsplacement = calculate_velocity_displacement(time, acc)
    omega = (2. * numpy.pi) / numpy.array(periods)
    omega2 = omega ** 2.
    omega3 = omega ** 3.
    omega_d = omega * math.sqrt(1.0 - (damping ** 2.))
    const = {'f1': (2.0 * damping) / (omega3 * dt),
            'f2': 1.0 / omega2,
            'f3': damping * omega,
            'f4': 1.0 / omega_d}
    const['f5'] = const['f3'] * const['f4']
    const['f6'] = 2.0 * const['f3']
    const['e'] = numpy.exp(-const['f3'] * dt)
    const['s'] = numpy.sin(omega_d * dt)
    const['c'] = numpy.cos(omega_d * dt)
    const['g1'] = const['e'] * const['s']
    const['g2'] = const['e'] * const['c']
    const['h1'] = (omega_d * const['g2']) - (const['f3'] * const['g1'])
    const['h2'] = (omega_d * const['g1']) + (const['f3'] * const['g2'])
    x_a, x_v, x_d = calculate_time_series(num_steps,num_per,time,acc,const,omega2)

    spectrum = {'Sa': None, 'Sv': None, 'Sd': None, 'T': None}
    spectrum['Sa'] = numpy.max(numpy.fabs(x_a)/9.81, axis=0)  
    spectrum['Sv'] = numpy.max(numpy.fabs(x_v), axis=0) 
    spectrum['Sd'] = numpy.max(numpy.fabs(x_d), axis=0) 
    spectrum['T'] = periods 
    
    return spectrum
        
def calculate_time_series(num_steps,num_per,time,acc,const, omega2):
    """
    Calculates the acceleration, velocity and displacement time series for
    the SDOF oscillator
    :param dict const:
        Constants of the algorithm
    :param np.ndarray omega2:
        Square of the oscillator period
    :returns:
        x_a = Acceleration time series
        x_v = Velocity time series
        x_d = Displacement time series
    """
    dt = time[1]-time[0]   
    x_d = numpy.zeros([num_steps - 1, num_per], dtype=float)
    x_v = numpy.zeros_like(x_d)
    x_a = numpy.zeros_like(x_d)
        
    for k in range(0, num_steps - 1):
        yval = k - 1
        dug = acc[k + 1] - acc[k]
        z_1 = const['f2'] * dug
        z_2 = const['f2'] * acc[k]
        z_3 = const['f1'] * dug
        z_4 = z_1 / dt
        if k == 0:
            b_val = z_2 - z_3
            a_val = (const['f5'] * b_val) + (const['f4'] * z_4)
        else:    
            b_val = x_d[k - 1, :] + z_2 - z_3
            a_val = (const['f4'] * x_v[k - 1, :]) +\
                (const['f5'] * b_val) + (const['f4'] * z_4)

        x_d[k, :] = (a_val * const['g1']) + (b_val * const['g2']) +\
            z_3 - z_2 - z_1
        x_v[k, :] = (a_val * const['h1']) - (b_val * const['h2']) - z_4
        x_a[k, :] = (-const['f6'] * x_v[k, :]) - (omega2 * x_d[k, :])
        
    return x_a, x_v, x_d
        
def calculate_velocity_displacement(time, acc):
    '''
    Returns the velocity and displacment time series using simple integration
    :param float time_step:
        Time-series time-step (s)
    :param numpy.ndarray acceleration:
        Acceleration time-history
    :returns:
        velocity - Velocity Time series (cm/s)
        displacement - Displacement Time series (cm)
    '''
    dt = time[1]-time[0]   
    velocity = dt * cumtrapz(acc, initial=0.)
    displacement = dt * cumtrapz(velocity, initial=0.)
    return velocity, displacement
    
def residual_lognormal_dist(coeffs,imls,fractions):

    mu = coeffs[0]
    sigma = coeffs[1]
    residual = abs(numpy.array(fractions) - lognorm.cdf(imls, sigma, scale=math.exp(mu)))

    return residual
    
def add_information(capacity_curves,attribute,type,data):
    
    no_capacity_curves = len(capacity_curves['Sa'])
    
    if attribute == 'heights' or attribute == 'periods' or attribute == 'gamma':           
        if type == 'value':
            values = []
            for icc in range(no_capacity_curves):
                values.append(data)
            capacity_curves[attribute] = values
        elif type == 'vector':
            capacity_curves[attribute] = data
        elif type == 'calculate' and attribute == 'periods': 
            periods = []
            for icc in range(no_capacity_curves):
                Sd = capacity_curves['Sd'][icc][data] 
                Sa = capacity_curves['Sa'][icc][data] 
                periods.append(2*math.pi*math.sqrt(Sd/(Sa*9.81)))
            capacity_curves[attribute] = periods
            
    elif attribute == 'yielding point':
        Sdy = []
        Say = []
        for icc in range(no_capacity_curves):
            Sdy.append(capacity_curves['Sd'][icc][data])
            Say.append(capacity_curves['Sa'][icc][data])
        capacity_curves['Sdy'] = Sdy 
        capacity_curves['Say'] = Say 
    else:
        print attribute + ' is not a recognized attribute. No information was added.'
        
    return capacity_curves
    