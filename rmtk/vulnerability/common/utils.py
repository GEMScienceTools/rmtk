# -*- coding: utf-8 -*-
import os
import numpy
from scipy import stats
import math
from scipy import interpolate
from scipy import optimize
import matplotlib.pyplot as plt

def read_capacity_curves(input_file):
    # This function reads one, or a set of capacity curves 
       
    file=open(input_file)
    data=file.readlines()
    for line in data:
        line = line.strip().split(',')      
        if line[0] == 'Vb-droof' and line[1] == 'TRUE':
            capacity_curves = read_Vbdroof_capacity_curves(data)
            break
        elif line[0] == 'Vb-dfloor' and line[1] == 'TRUE':
            capacity_curves = read_Vbdfloor_capacity_curves(data)
            break
        elif line[0] == 'Sd-Sa' and line[1] == 'TRUE':
            capacity_curves = read_SdSa_capacity_curves(data)
            break

    return capacity_curves
    
def read_Vbdfloor_capacity_curves(data):
    
    capacity_curves = 'functin does not exist yet'
    
    return capacity_curves
    
def read_Vbdroof_capacity_curves(data):
    
    capacity_curves = 'functin does not exist yet'
    
    return capacity_curves
    
def read_SdSa_capacity_curves(data):

    # This function reads Sd-Sa type of capacity curves
    periods = []
    heights = []
    gammas = []
    Sdy = []
    Say = []
    Sd = []
    Sa = []
    
    for line in data:
        line = line.split(',')
        if line[0] == 'Periods [s]':
            for value in line[1:]:
                periods.append(float(value))
        if line[0] == 'Heigths [m]':
            for value in line[1:]:
                heights.append(float(value))
        if line[0] == 'Gamma participation factors':
            for value in line[1:]:
                gammas.append(float(value))
        if line[0] == 'Sdy':
            for value in line[1:]:
                Sdy.append(float(value))
        if line[0] == 'Say':
            for value in line[1:]:
                Say.append(float(value))
        if line[0][0:2] == 'Sd' and isNumber(line[0][2]):
            subSd = []
            for value in line[1:]:
                subSd.append(float(value))
            Sd.append(subSd)
        if line[0][0:2] == 'Sa' and isNumber(line[0][2]):
            subSa = []
            for value in line[1:]:
                subSa.append(float(value))
            Sa.append(subSa)

    # Store all the data in the dictionary
    capacity_curves = {'periods': None, 'heights': None, 'gamma': None,
        'Sdy': None, 'Say': None, 'Sd': None, 'Sa': None}

    capacity_curves['periods'] = periods
    capacity_curves['heights'] = heights
    capacity_curves['gamma'] = gammas
    capacity_curves['Sdy'] = Sdy
    capacity_curves['Say'] = Say
    capacity_curves['Sd'] = Sd
    capacity_curves['Sa'] = Sa
        
    return capacity_curves
    
def plot_capacity_curves(capacity_curves):
    
    #This function plots the capacity curves
    no_capacity_curves = len(capacity_curves['Sa'])
    for icc in range(no_capacity_curves):
        Sa = capacity_curves['Sa'][icc]
        Sd = capacity_curves['Sd'][icc]
        plt.plot(Sd,Sa,color='g',linewidth=2)

    plt.plot(Sd,Sa,color='g',linewidth=2,label='individual capacity curve')
    plt.xlabel('Spectral displacement',fontsize = 10)
    plt.ylabel('Spectral acceleration',fontsize = 10)
    plt.suptitle('Capacity curves')
    plt.legend(loc='lower right',frameon = False)
    plt.show()
    
def read_gmrs(folder):
    
    #This function reads a set of ground motion records
    #and stores them in a dictionary
    time = []
    acc = []
    for file in os.listdir(folder):
        if file.endswith(".csv"):
            itime, iacc = read_gmr(folder,file)
            time.append(itime)
            acc.append(iacc)
          
    gmrs = {'time': None, 'acc': None}
    gmrs['time'] = time  
    gmrs['acc'] = acc  

    return gmrs       
            
def read_gmr(folder,gmr):
    
    file=open(folder+'/'+gmr)
    lines=file.readlines()
    time = []
    acc = []
    for line in lines:
        line = line.split(',')
        time.append(float(line[0]))
        acc.append(float(line[1])*9.81)   
        
    return time, acc
    
def plot_response_spectra(gmrs,minT,maxT):
    
    no_gmrs = len(gmrs['time'])
    damping = 0.05
    T = numpy.linspace(minT,maxT,50)
    plt.figure(figsize=(15,5))
    for igmr in range(no_gmrs):
        acc = gmrs['acc'][igmr]
        time = gmrs['time'][igmr]
        spectrum = compute_spectrum(acc,time,T,damping)
        plt.subplot(1, 3, 1)
        plt.plot(T,spectrum['Sa'],color='g',linewidth=2)
        plt.subplot(1, 3, 2)
        plt.plot(T,spectrum['Sd'],color='g',linewidth=2)
        plt.subplot(1, 3, 3)
        plt.plot(spectrum['Sd'],spectrum['Sa'],color='g',linewidth=2)
    
    plt.subplot(1, 3, 1)
    plt.xlabel('Periods of vibration (sec)',fontsize = 10)
    plt.ylabel('Spectral acceleration (g)',fontsize = 10)
    plt.subplot(1, 3, 2)
    plt.xlabel('Periods of vibration (sec)',fontsize = 10)
    plt.ylabel('Spectral displacement (m)',fontsize = 10)
    plt.subplot(1, 3, 3)
    plt.xlabel('Spectral displacement (m)',fontsize = 10)
    plt.ylabel('Spectral acceleration (g)',fontsize = 10)
    plt.show()
    
def compute_spectrum(acc,time,T,damping):
	
    u0 = 0
    v0 = 0
    dt = time[1]-time[0]   
    no_acc = len(acc)
    no_T = len(T)
    M = 1
    Sd = numpy.zeros(no_T)
    Sa = numpy.zeros(no_T)
    u = numpy.zeros(no_acc)
    a = numpy.zeros(no_acc)
    v = numpy.zeros(no_acc)
    at = numpy.zeros(no_acc)
    
    for i in range(no_T):
        if T[i] == 0:
            Sd[i] = 0
            Sa[i] = max(abs(numpy.array(acc)))
        else:
            wn = 2*math.pi/T[i]
            C = damping*2*M*wn
            K = ((2*math.pi)/T[i])**2*M
            u[0] = u0                                    
            v[0] = v0
            a[0] = -acc[0]-C*v[0]-K*u[0]
            at[0] = acc[0]+a[0]
            for j in range(no_acc-1):
                u[j+1] = u[j]+dt*v[j]+dt**2/2*a[j]
                a[j+1] = (1/(M+dt*0.5*C))*(-M*acc[j+1]-K*u[j+1]-C*(v[j]+dt*0.5*a[j]))
                v[j+1] = v[j]+dt*(0.5*a[j]+0.5*a[j+1])
                at[j+1] = acc[j+1]+a[j+1]
            
            Sd[i]=max(abs(u))
            Sa[i]=max(abs(at))/9.81
 
    spectrum = {'Sd': None, 'Sa': None}
    spectrum['Sd'] = Sd  
    spectrum['Sa'] = Sa      
    
    return spectrum
    
def isNumber(s):
    try: 
        float(s)
        return True
    except ValueError:
        return False
        
def read_damage_model(input_file):
    
    damage_states = []
    type_damage_state = []
    mean = []
    cov = []
    file=open(input_file)
    data=file.readlines()
    line = data[0]
    line = line.strip().split(',')
    type_criteria = line[1]
    
    if type_criteria == 'capacity curve dependent':
        for iline in range(len(data)-2):
            line = data[iline+2]
            line = line.strip().split(',')
            damage_states.append(line[0])
            type_damage_state.append(line[1])
            if isNumber(line[2]):
                mean.append(float(line[2]))
            else:
                mean.append(line[2])
            cov.append(float(line[3]))
            
    damage_model = {'type_criteria': None, 'damage_states': None,
        'type_damage_state': None, 'mean': None, 'cov': None}
    damage_model['type_criteria'] = type_criteria  
    damage_model['damage_states'] = damage_states  
    damage_model['type_damage_state'] = type_damage_state  
    damage_model['mean'] = mean  
    damage_model['cov'] = cov
    
    return damage_model
    
def define_limit_states(capacity_curves,icc,damage_model):

    no_damage_states = len(damage_model['damage_states'])
    limit_states = []
    if damage_model['type_criteria'] == 'capacity curve dependent':
        Sd = capacity_curves['Sd'][icc]
        Sa = capacity_curves['Sa'][icc]
        Sdy = capacity_curves['Sdy'][icc]
        Say = capacity_curves['Say'][icc] 
        for ids in range(no_damage_states):
            type_damage_state = damage_model['type_damage_state'][ids]
            mean = damage_model['mean'][ids]
            cov = damage_model['cov'][ids]
            limit_states.append(define_limit_state(Sd,Sa,Sdy,Say,type_damage_state,mean,cov))
    
    return limit_states
    
def define_limit_state(Sd,Sa,Sdy,Say,type_damage_state,mean,cov):

    if type_damage_state == 'Sdy':
        mean = Sdy
        limit_state = sample_limit_state(mean,cov)
        
    elif type_damage_state == 'Sdu':     
        mean = max(Sd)
        limit_state = sample_limit_state(mean,cov)

    elif type_damage_state == 'fraction Sdy':
        mean = mean*Sdy
        limit_state = sample_limit_state(mean,cov)
        
    elif type_damage_state == 'mean Sdy Sdu':
        mean = (Sdy+max(Sd))/2
        limit_state = sample_limit_state(mean,cov)
        
    return limit_state
    
def sample_limit_state(mean,cov):
    
    if cov == 0:
        sampled_limit_state = mean
    else:
        sampled_limit_state = stats.norm.rvs(mean,mean*cov)
    
    return sampled_limit_state
 
def find_intersection(curve1,curve2,plot_flag):
    
    x1 = numpy.array(curve1[0])
    x2 = numpy.array(curve2[0])
    y1 = numpy.array(curve1[1])
    y2 = numpy.array(curve2[1])
    
    min_x = max([min(x1),min(x2)])
    max_x = min([max(x1),max(x2)])
    range_x = x2[numpy.where(numpy.logical_and(x2>min(x1),x2<max(x1)))]
    
    if len(range_x)>0:
        range_x = spread(range_x,10)
        y2_range_x = spread(y2[numpy.where(numpy.logical_and(x2>min(x1),x2<max(x1)))],10)
        interpolator = interpolate.interp1d(x1,y1,kind = 'linear')
        y1_range_x = interpolator(range_x)

        delta = y2_range_x - y1_range_x
        sign_delta = delta[:-1]*delta[1:]
   #     print delta
#        print sign_delta
        root_loc = numpy.where(numpy.logical_and(abs(delta[:-1])<0.03, sign_delta<0))
        intersect_x = range_x[root_loc]
        intersect_y = y1_range_x[root_loc]
            
        if plot_flag:
            plt.plot(range_x,y1_range_x,color='r',linewidth=2)
            plt.plot(x2,y2,color='b',linewidth=2)
            plt.xlabel('Spectral displacement',fontsize = 10)
            plt.ylabel('Spectral acceleration',fontsize = 10)
            plt.plot(intersect_x,intersect_y, 'ro',color='y')
            plt.show()       
    else:
        intersect_x = []
        intersect_y = []
        
    return intersect_x,intersect_y
    
def spread(array,no_steps):
    
    result = numpy.zeros((len(array)-1)*no_steps+1)
    
    for i in range(len(array)-1):
        result[i*no_steps]=array[i]
        step = (array[i+1]-array[i])/no_steps
        for j in range(no_steps):
            result[i*no_steps+j+1]=array[i]+(j+1)*step
            
    result[-1]=array[-1]

    return result
    
def allocate_damage(igmr,PDM,disp,limitStates):
    
    no_ls = len(limitStates)
    PDM[igmr,0]=PDM[igmr,0]+1
    for ils in range(no_ls):
        if disp > limitStates[no_ls-ils-1]:
            PDM[igmr,no_ls-ils]=PDM[igmr,no_ls-ils]+1
            PDM[igmr,0]=PDM[igmr,0]-1
            break
    
    return PDM
    
def residuals(coeffs,y,x):
	
	res = y - stats.lognorm.cdf(IMLs, coeffs[1], scale=scipy.exp(coeffs[0]))
    
	return res