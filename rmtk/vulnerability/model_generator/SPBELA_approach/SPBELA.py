# -*- coding: utf-8 -*-
import os
import numpy
import math
import scipy
import csv
import matplotlib.pyplot as plt
from rmtk.vulnerability.common import utils

def read_building_class_model(filename):
       
    file=open(filename)
    data=csv.reader(file)
    for line in data:
        if line[0] == 'Structure type' and line[1] == 'bare frame':
            building_model = read_rc_frames_building_model(data,line[1])
            break
        elif line[0] == 'Structure type' and line[1] == 'infilled frame':
            building_model = read_rc_frames_building_model(data)
            break
        elif line[0] == 'Structure type' and line[1] == 'masonry':
            building_model = read_masonry_building_model(data)
            break
            
    return building_model
    
def read_rc_frames_building_model(data,structure_type):

    for line in data:
        if line[0] == 'ductility':
            ductility = line[1]
        if line[0] == 'number of storeys':
            no_storeys = int(line[1])
        if line[0] == 'steel modulus':
            steel_modulus = line[1:]
        if line[0] == 'steel yield strength':
            steel_yieled_strength = line[1:]
        if line[0] == 'concrete strength':
            concrete_strength = line[1:]
        if line[0] == 'steel bar diameter':
            steel_bar_diameter = line[1:]
        if line[0] == 'ground floor height':
            ground_height = line[1:]
        if line[0] == 'regular floor height':
            regular_height = line[1:]
        if line[0] == 'column depth':
            column_depth = line[1:]  
        if line[0] == 'beam length':
            beam_length = line[1:]
        if line[0] == 'beam depth':
            beam_depth = line[1:]
            
    # Store all the data in the dictionary
    building_model = {'structure_type': None, 'ductility': None, 'no_storeys': None,
        'steel_modulus': None, 'steel_yieled_strength': None, 'ground_height': None,
        'column_depth': None, 'beam_length': None, 'beam_depth': None}

    building_model['structure_type'] = structure_type
    building_model['ductility'] = ductility
    building_model['no_storeys'] = no_storeys
    building_model['steel_modulus'] = steel_modulus
    building_model['steel_yieled_strength'] = steel_yieled_strength 
    building_model['concrete_strength'] = concrete_strength
    building_model['steel_bar_diameter'] = steel_bar_diameter 
    building_model['ground_height'] = ground_height 
    building_model['regular_height'] = regular_height
    building_model['column_depth'] = column_depth
    building_model['beam_length'] = beam_length
    building_model['beam_depth'] = beam_depth
    return building_model
    
def read_masonry_building_model(data):
    
    building_model = 'Function not yet implemented.'
    
    return building_model

def generate_assets(building_model,no_cc):
        
    generated_cc = 0
    steel_modulus = []
    steel_yieled_strength = []
    concrete_strength = []
    steel_bar_diameter = []
    ground_height = []
    regular_height = []
    height = []
    column_depth = []
    beam_length = []
    beam_depth = []
    structure_type = building_model['structure_type']
    
    while generated_cc < no_cc:
        if structure_type == 'bare frame' or structure_type == 'infilled frame':
            
            steel_modulus.append(sample_value(building_model['steel_modulus']))
            steel_yieled_strength.append(sample_value(building_model['steel_yieled_strength'])) 
            concrete_strength.append(sample_value(building_model['concrete_strength']))
            steel_bar_diameter.append(sample_value(building_model['steel_bar_diameter'])) 
            ground_height.append(sample_value(building_model['ground_height'])) 
            column_depth.append(sample_value(building_model['column_depth']))
            beam_length.append(sample_value(building_model['beam_length']))
            beam_depth.append(sample_value(building_model['beam_depth']))
            if building_model['no_storeys'] > 1:
                regular_height.append(sample_value(building_model['regular_height']))
                height.append(ground_height[-1]+(building_model['no_storeys']-1)*regular_height[-1])
            else:
                height.append(ground_height[-1])
        generated_cc = generated_cc + 1
        
    assets = {'structure_type': None, 'ductility': None, 'no_storeys': None,
        'steel_modulus': None, 'steel_yieled_strength': None, 'ground_height': None,
        'regular_height': None, 'column_depth': None, 'beam_length': None, 
        'beam_depth': None}
        
    assets['structure_type'] = structure_type
    assets['ductility'] = building_model['ductility']
    assets['no_storeys'] = building_model['no_storeys']
    assets['steel_modulus'] = steel_modulus
    assets['steel_yieled_strength'] = steel_yieled_strength
    assets['concrete_strength'] = concrete_strength
    assets['steel_bar_diameter'] = steel_bar_diameter
    assets['ground_height'] = ground_height
    assets['height'] = height
    assets['column_depth'] = column_depth
    assets['beam_length'] = beam_length
    assets['beam_depth'] = beam_depth
    if building_model['no_storeys'] > 1:
        assets['regular_height'] = regular_height
            
    return assets
    
def sample_value(data):
    
    if data[0] == 'discrete':
        sampled_value = calculate_discrete_prob_value(data)
    else:
        sampled_value = calculate_continuous_prob_value(data)
    
    return sampled_value
    
def calculate_discrete_prob_value(data):

    x_values = data[1].split(' ')
    y_probabilities = map(float,data[2].split(' '))
    min_value = float(data[3])
    max_value = float(data[4])
    result = float('-inf')

    cum_probability = numpy.cumsum(numpy.hstack((0,y_probabilities)))
    while result <= min_value or result >= max_value:
        rand_value = scipy.stats.uniform.rvs()
        for i in range(len(y_probabilities)):
            if rand_value > cum_probability[i] and rand_value < cum_probability[i+1]: 
                result = float(x_values[i])
	
    return result
    
def calculate_continuous_prob_value(data):
    
    distribution = data[0]
    mean = float(data[1])
    stddev = float(data[2])*mean
    min_value = float(data[3])
    max_value = float(data[4])
    result = float('-inf')
	   
    while result <= min_value or result >= max_value:
        if distribution == "normal":	
            result = scipy.stats.norm.rvs(mean,stddev)
		
        elif distribution == "lognormal":
            variance = stddev ** 2.0
            mu = math.log(mean ** 2.0 / math.sqrt(variance + mean ** 2.0) )
            sigma = math.sqrt(math.log((variance / mean ** 2.0) + 1.0))
            result = scipy.stats.lognorm.rvs(sigma, scale=scipy.exp(mu))

        elif distribution == "gamma":
            beta = stddev**2/mean
            alpha = mean/beta
            result = scipy.stats.gamma.rvs(alpha,scale = beta)

	return result
    
def generate_capacity_curves(assets,damage_model):
    
    no_assets = len(assets['height'])
    Sd = []
    Sa = []
    Sdy = []
    Say = []
    heights = []
    periods = []
    zero_col = numpy.zeros((no_assets,1))
    
    for iasset in range(no_assets):
        collapse_type = calculate_collapse_type(assets,iasset)
        Sd.append(calculate_Sd(assets,iasset,collapse_type,damage_model))
        ductilities = calculate_ductilities(Sd[-1])
        period = calculate_periods(assets,iasset,ductilities)
        Sa.append(calculate_Sa(Sd[-1],period))
        Sdy.append(Sd[-1][0])
        Say.append(Sa[-1][0])
        periods.append(period[0])
        heights.append(assets['height'][iasset])

    capacity_curves = {'type': None, 'periods': None, 'heights': None, 
        'gamma': None, 'Sdy': None, 'Say': None, 'Sd': None, 'Sa': None}

    Sa = numpy.array(Sa)
    Sd = numpy.array(Sd)
    Sa = numpy.hstack((zero_col,Sa))
    Sd = numpy.hstack((zero_col,Sd))

    capacity_curves['type'] = 'Sd-Sa'
    capacity_curves['Sd'] = Sd
    capacity_curves['Sa'] = Sa 
    capacity_curves['heights'] = heights
    capacity_curves['periods'] = periods

    return capacity_curves
    
def calculate_collapse_type(assets,iasset):
    
    structure_type=assets['structure_type']
    no_storeys=assets['no_storeys']
    ground_height=assets['ground_height'][iasset]
    column_depth=assets['column_depth'][iasset]
    beam_length=assets['beam_length'][iasset]
    beam_depth=assets['beam_depth'][iasset]
    if no_storeys > 1:
        regular_height=assets['regular_height'][iasset]
        
    if structure_type == 'bare frame' or structure_type == 'infilled frame':
        r_gf = (beam_depth/beam_length)/(column_depth/ground_height)
        r_uf = 0
        if no_storeys > 1:
            r_uf=(beam_depth/beam_length)/(column_depth/regular_height)
        if max(r_gf, r_uf) > 1.5:
            collapse_type = 'column sway'
        else:
            collapse_type = 'beam sway'

    return collapse_type
    
def calculate_Sd(assets,iasset,collapse_type,damage_model): 
    
    Sd =[]
    structure_type = assets['structure_type']
    
    if structure_type == 'bare frame':
        steel_modulus = assets['steel_modulus'][iasset]
        steel_yield = assets['steel_yieled_strength'][iasset]
        ey = steel_yield/steel_modulus

        efh = calculate_efh(assets,ey,damage_model,collapse_type)
        chord_rotations = calculate_chord_rotation(assets,iasset,collapse_type,damage_model)
        height = assets['height'][iasset]
        
        if collapse_type == 'beam sway':
            Sd.append(chord_rotations[0]*efh*height)
            for irotations in range(len(chord_rotations)-1):
                Sd.append(Sd[0]+(chord_rotations[irotations+1]-chord_rotations[0])*efh*height)
            
        if collapse_type == 'column sway': 
            ground_height = assets['ground_height'][iasset]
            Sd.append(chord_rotations[0]*efh*height)
            for irotations in range(len(chord_rotations)-1):
                Sd.append(Sd[0]+(chord_rotations[irotations+1]-chord_rotations[0])*ground_height)
    
    return Sd
    
def calculate_chord_rotation(assets,iasset,collapse_type,damage_model):
        
    chord_rotations = []
    no_storeys = assets['no_storeys']
    steel_modulus = assets['steel_modulus'][iasset]
    steel_yield = assets['steel_yieled_strength'][iasset]
    ground_height = assets['ground_height'][iasset]
    concrete_strength = assets['concrete_strength'][iasset]
    steel_bar_diameter = assets['steel_bar_diameter'][iasset]
    ey = steel_yield/steel_modulus
    strain_ult_conc = damage_model['mean'][-1][0]
    strain_ult_steel = damage_model['mean'][-1][1]

    if collapse_type == 'beam sway':
        section_height = assets['beam_depth'][iasset]
        chord_length = assets['beam_length'][iasset]
    elif collapse_type == 'column sway':
        section_height = assets['column_depth'][iasset]
        chord_length = assets['height'][iasset]
        
    Lv = chord_length/2
    gamma_el = 1.5
    yield_curvature = 2.14*ey/section_height
    ultimate_curvature = (strain_ult_conc+strain_ult_steel)/section_height
    Lpl = 0.1*Lv+0.17*section_height+0.24*steel_bar_diameter*steel_yield/math.sqrt(concrete_strength)
    
    yield_rotation = yield_curvature*Lv/3+0.0013*(1.0+1.5*section_height/Lv)+0.13*yield_curvature*steel_bar_diameter*steel_yield/math.sqrt(concrete_strength)
    ultimate_rotation = 1/gamma_el*(yield_rotation+(ultimate_curvature-yield_curvature)*Lpl*(1-0.5*Lpl/Lv))
    chord_rotations.append(yield_rotation)
    for ids in range(len(damage_model['damage_states'])):
        if damage_model['type_damage_state'][ids] == 'fraction Sdu':
            distribution = damage_model['distribution'][ids]
            mean = damage_model['mean'][ids][0]*ultimate_rotation
            cov = damage_model['cov'][ids][0]
            chord_rotations.append(utils.sample_limit_state(distribution,mean,cov))
    
    chord_rotations.append(ultimate_rotation)
    
    return chord_rotations
    
def calculate_efh(assets,ey,damage_model,collapse_type):

    structure_type = assets['structure_type']
    no_storeys = assets['no_storeys']
    strain_ult_steel = damage_model['mean'][-1][1]
    
    if structure_type == 'bare frame' or structure_type == 'infilled frame':

        if collapse_type == 'beam sway':
            if no_storeys <= 4:
                efh = 0.64
            elif no_storeys > 4 and no_storeys < 20:
                efh = 0.64-0.0125*(no_storeys-4)
            elif no_storeys >= 20:
                efh = 0.44
            
        if collapse_type == 'column sway': 
            efh = 0.67
        
    return efh
    
def calculate_ductilities(Sd):
        
    ductilities = []
    for i in range(len(Sd)):
        ductilities.append(Sd[i]/Sd[0])

    return ductilities
    
def calculate_periods(assets,iasset,ductilities):
   
    periods = [] 
    no_storeys = assets['no_storeys']
    structure_type = assets['structure_type']
    ductility = assets['ductility']
    height = assets['height'][iasset]  
        
    if structure_type == 'bare frame':
        periods.append(0.070*height)
        
    if structure_type == 'infilled frame':
        if ductility == "non-ductile":
            periods.append(0.060*height)
        if ductility == "ductile":
            periods.append(0.042*height)
    
    periods.append(periods[0]*math.sqrt(ductilities[1]))
    periods.append(periods[0]*math.sqrt(ductilities[2]))
            
    return periods
    
def calculate_Sa(Sd,periods):

    Sa = []
    Sa.append((Sd[0]*4*(math.pi)**2)/(9.81*periods[0]**2))
    Sa.append((Sd[0]*4*(math.pi)**2)/(9.81*periods[0]**2))
    Sa.append((Sd[0]*4*(math.pi)**2)/(9.81*periods[0]**2))
        
    return Sa