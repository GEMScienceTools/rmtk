# -*- coding: utf-8 -*-
import os
import numpy
import math
import csv
import matplotlib.pyplot as plt
from rmtk.vulnerability.common import utils
from scipy.stats import lognorm

def calculate_convolution(hazard_curve,fragility_model,return_period,damage_state,save,plot,typology):
#This function calculates the annual probability of collapse given a hazard 
#curve and a fragility model

    rate_exceed = []
    segment_limit = []
    segment_width = []
    imls = []
    prob_exceed = []
    frag_curve = []
    damage_rate_dist = []
   
    #1. Calculate the annual rate of exceedance
    for iIML in range(len(IMLs)):
        imls.append(hazard_curve[IMLs][iIML])
        prob_exceed.append(hazard_curve['PoE'][iIML])
        rate_exceed.append(-math.log(1-prob_exceed[iIML])/return_period)
      
    #2. Divide the curve into segments and derive the rate of occurrence 
    #   of the associated central IML value
    for iIML in range(len(imls)-1):
        segment_limit.append((imls[iIML]+imls[iIML+1])/2)
   
    segment_width.append(segment_limit[0])
    for iDelta in range(len(imls)-2):
        k = iDelta + 1
        segment_width.append(segment_limit[k] - segment_limit[(k-1)])
        segment_width.append(imls[-1] - segment_limit[-1])
      
    #3. Read fragility curve of interest and estimate the probability of 
    #   reaching the DS of interest, given the values of IML
    ds = fragility_model['Damage_states'].index(damage_state)
    mean = fragility_model['log_mean'][ds]
    stdev = fragility_model['log_stdev'][ds]
    for iIML in range(len(imls)):
        frag_curve.append(lognorm.cdf(imls, stdev, loc=0, scale=math.exp(mean))
      
    #4. Calculate the damage rate distribution for the given IML
    damage_rate_dist.append(rate_exceed[iIML]*frag_curve[iIML]*segment_width[iIML])
    if plot:
        plt.hist(dist_rate)
        plt.title("Distribution of Collapse Rate")
        if hazard_curve[IM_Type] = 'PGA':
            plt.xlabel("Peak ground acceleration [g]")
        else:
            plt.xlabel("Spectral acceleration [g]")
        plt.ylabel("Annual rate of collapse")
        plt.show
         
    #5. Calculate the annual damage rate (ADR) and annual probability of damage (APD)
    ADR = sum(damage_rate_dist)
    APD = (math.exp(ADR*1)-1)/math.exp(ADR*1)
    if save:
        create_conv_output(ADR,APD,typology)
      
    return APD

def create_conv_output(ADR,APD,typology):
#This function creates a file with the outcome of the convolution process
    path = '../../../../../../rmtk_data/output'
    if typology:
        out_name = typology + '.csv'
    else:
        out_name = 'Convolution_output.csv'
    out_file = open(os.path.join(path,out_name),'w')
    out_file.write('Annual damage rate, %f \n' %ADR)
    out_file.write('Annual probability of damage, %f \n' %APD)
    out_file.close()

def read_hazard(input_file):    
#This function reads a hazard curve and stores it in a dictionary

    file = open(input_file)
    data = csv.reader(file)
    IMLs = []
    prob_exceedance = []
    IM_type = []
    for line in data:
        if line[0] == 'PGA':
            IM_type.append(line[0])
            for value in line[1:]:
                if isNumber(value):    
                    IMLs.append(float(value))
        if line[0] == 'Sa':
            IM_type.append(line[0])
            for value in line[1:]:
                if isNumber(value):
                    IMLs.append(float(value))
        if line[0] == 'PoE':
            for value in line[1:]:
                if isNumber(value):
                    prob_exceedance.append(float(value))
                
    #Store all the data in the dictionary
    hazard_curve = {'IMLs':None,'PoE':None,'IM_Type':None}
    hazard_curve['IMLs'] = IMLs
    hazard_curve['PoE'] = prob_exceedance
    hazard_curve['IM_Type'] = IM_type
      
    return hazard_curve
      
def plot_hazard_curve(hazard_curve):
#This function plots the hazard curve

    IMLs = hazard_curve['IMLs']
    PoE = hazard_curve['PoE']
    plt.plot(IMLs,PoE,color='g',linewidth=2)
    plt.xlabel(hazard_curve['IM_Type'][0] + ' [g]',fontsize = 10)
    plt.ylabel('Probability of Exceedance',fontsize = 10)

def read_frag_model(input_file):    
#This function reads a fragility model and stores it in a dictionary

    damage_states = []
    model_type = []
    cent_value = []
    dispersion = []
    log_mean = []
    log_stdev = []
        
    file = open(input_file)
    data = file.readlines()
    line = data[0]
    line = line.strip().split(',')
    model_type = line[1] + ' - ' + line[2]
    
    file = open(input_file)
    data = csv.reader(file)
    data = [row for row in data]
    for iline in range(len(data)-1):
        line = data[iline+1]
        damage_states.append(line[0])
        cent_value.append(line[1])
        dispersion.append(line[2])
    
    if model_type == ' median - dispersion':
        for ids in range(len(cent_value)):
            mean = math.log(cent.value[ids])
            stdev = dispersion[ids]
            log_mean.append(mean)
            log_stdev.append(stdev)
    elif model_type == 'mean of x - cov of x':
        for ids in range(len(cent_value)):
            mu = cent.value[ids]
            cov = dispersion[ids]
            median = (mu**2)/math.sqrt(mu**2+cov**2)
            mean = math.log(median)
            stdev = math.sqrt(math.log(1+(cov**2)/mu**2))
            log_mean.append(mean)
            log_stdev.append(stdev)
    elif model_type == 'mean of ln(x) - st. dev. of ln(x)':
        for ids in range(len(cent_value)):
            mean = cent_value[ids]
            stdev = line[ids]
            log_mean.append(mean)
            log_stdev.append(stdev)
       
    #Store all the data in the dictionary
    fragility_model =  {'Damage_states':None,'log_mean':None,'log_stdev':None}
    fragility_model['Damage_states'] = damage_states
    fragility_model['log_mean'] = log_mean
    fragility_model['log_stdev'] = log_stdev
       
    return fragility_model