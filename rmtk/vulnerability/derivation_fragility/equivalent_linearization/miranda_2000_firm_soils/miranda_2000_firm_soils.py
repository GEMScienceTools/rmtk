# -*- coding: utf-8 -*-
import os
import numpy
import math
from scipy import interpolate
from scipy import optimize
import matplotlib.pyplot as plt
from rmtk.vulnerability.common import utils

def calculate_fragility(capacity_curves,gmrs,damage_model,damping):
#This function returns a damage probability matrix (PDM) and the corresponding spectral displacements
#after an iterative process to find the minimum Sd value for each case 

    no_damage_states = len(damage_model['damage_states'])
    no_gmrs = len(gmrs['time'])
    no_capacity_curves = len(capacity_curves['Sd'])
    PDM = numpy.zeros((no_gmrs,no_damage_states+1))
    Sds = numpy.zeros((no_gmrs,no_capacity_curves))
    for icc in range(no_capacity_curves):
        print str((icc+1)*100/no_capacity_curves) + '%'
        Te = capacity_curves['periods'][icc]
        Sdy = capacity_curves['Sdy'][icc]
        for igmr in range(no_gmrs):
            limit_states = utils.define_limit_states(capacity_curves,icc,damage_model)
            time = gmrs['time'][igmr]
            acc = gmrs['acc'][igmr]
            spec_Te = utils.NigamJennings(time,acc,[Te],damping) 
            Sdi = optimize.fmin(calculate_Sd, Sdy, args=(spec_Te['Sd'],capacity_curves,icc), xtol=0.001, ftol=0.001, disp = False, )
            [PDM, ds] = utils.allocate_damage(igmr,PDM,Sdi,limit_states)
            Sds[igmr][icc] = Sdi
    return PDM, Sds

def calculate_Sd(old_Sd,Sd_Te,capacity_curves,icc):
#This function estimates the inelastic displacements based on the elastic displacement 
#and the ratio C
             
    Sdy = capacity_curves['Sdy'][icc]
        
    if Sdy>Sd_Te:
        new_Sd = Sd_Te
    else:
        nu = old_Sd/Sdy
        Te = capacity_curves['periods'][icc]
        C = (1+(1/nu-1)*math.exp(-12*Te*nu**-0.8))**-1
        new_Sd = Sd_Te*C
    
    error = abs(new_Sd-old_Sd)
  
    return error
