# -*- coding: utf-8 -*-
import os
import numpy
import math
from scipy import interpolate
from scipy import optimize
import matplotlib.pyplot as plt
from rmtk.vulnerability.common import utils

def calculate_fragility(capacity_curves,gmrs,damage_model,damping,hyst_model,damping_mod):
#This function returns a damage probability matrix (PDM) and the corresponding spectral displacements
    
    no_damage_states = len(damage_model['damage_states'])
    no_gmrs = len(gmrs['time'])
    no_capacity_curves = len(capacity_curves['Sd'])
    PDM = numpy.zeros((no_gmrs,no_damage_states+1))
    Sds = numpy.zeros((no_gmrs,no_capacity_curves))
    for icc in range(no_capacity_curves):
        print str((icc+1)*100/no_capacity_curves) + '%'
        limit_states = utils.define_limit_states(capacity_curves,icc,damage_model)
        Te = capacity_curves['periods'][icc]
        Sdy = capacity_curves['Sdy'][icc]
        for igmr in range(no_gmrs):
            time = gmrs['time'][igmr]
            acc = gmrs['acc'][igmr]
            spec_Te = utils.NigamJennings(time,acc,[Te],damping) 
            spec_10sec = utils.NigamJennings(time,acc,[1.0],damping) 
            spec_03sec = utils.NigamJennings(time,acc,[0.3],damping) 
            Tc = spec_10sec['Sa']/spec_03sec['Sa'];
            Sdi = optimize.fmin(calculate_Sd, Sdy, args=(spec_Te['Sd'],Tc,capacity_curves,icc,hyst_model,damping_mod), xtol=0.001, ftol=0.001, disp = False, )
            PDM = utils.allocate_damage(igmr,PDM,Sdi,limit_states)
            Sds[igmr][icc] = Sdi
    return PDM, Sds

def calculate_Sd(old_Sd,Sd_Te,Tc,capacity_curves,icc,hyst_model,damping_mod):
#This function calculates the inelastic spectral displacements based on the
#elastic spectral displacements 
             
    Sdy = capacity_curves['Sdy'][icc]
    
    if Sdy>Sd_Te:
        new_Sd = Sd_Te
    else:
        nu = old_Sd/Sdy
        Te = capacity_curves['periods'][icc]
        c1,c2,cR,cT = get_parameters(hyst_model,damping_mod)
        Tc1 = min([c2*(nu**cT)*Tc,Tc])
        if Te <= Tc1:
            C = nu*(c1*(nu-1)**cR*Te/Tc1+1)**-1
        else:
            C = nu*(c1*(nu-1)**cR+1)**-1
        new_Sd = Sd_Te*C
    
    error = abs(new_Sd-old_Sd)
  
    return error

def get_parameters(hyst_model,damping_mod):
#This function returns the required constants, dependant on the hysteresis
#and damping model

    if hyst_model == 'Q':
        cR = 1.0
        c2 = 0.65
        cT = 0.30
        if damping_model == 'Mass':
            c1 = 1.0
        elif damping_model == 'Inst_stif':
            c1 = 0.75
    elif hyst_model == 'Bilinear':
        cR = 0.95
        c2 = 0.75
        cT = 0.20
        if damping_model == 'Mass':
            c1 = 1.35
        if damping_model == 'Inst_stif':
            c1 = 1.10
    else:
        c1 = 1.35
        cR = 1.95
        c2 = 0.75
        cT = 0.20
    return c1,c2,cR,cT