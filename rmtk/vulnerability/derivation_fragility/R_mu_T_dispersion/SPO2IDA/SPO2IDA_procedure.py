# -*- coding: utf-8 -*-

import numpy as np
import scipy.stats as stat
import os
from rmtk.vulnerability.common import utils
from rmtk.vulnerability.mdof_to_sdof import sdof_utils
pi = 3.141592653589793
from rmtk.vulnerability.derivation_fragility.R_mu_T_dispersion.SPO2IDA.spo2ida_based.get_spo2ida_parameters import get_spo2ida_parameters
from rmtk.vulnerability.derivation_fragility.R_mu_T_dispersion.SPO2IDA.spo2ida_based.spo2ida_allTfunction import spo2ida_allT

def calculate_fragility(capacity_curves, idealised_capacity, damage_model, MC, Sa_ratios, plotflag):
    pw = 1
    filletstyle = 3
    linew = 1
    fontsize = 11
    N = 10
    
    allSa, allbTSa, allLR50, allbLR = [],[],[],[]
    no_capacity_curves = len(capacity_curves['Vb'])
    g = 9.81
    w = capacity_curves['weights']
    Tav = capacity_curves['mean_period']

    for icc in range(0,no_capacity_curves):
        # Derive median Sa value (median of Sa) of capacity for each Limit State and corresponding overall dispersion std(log(Sa))
        T = capacity_curves['periods'][icc]
        Gamma = capacity_curves['gamma'][icc]
        if len(damage_model['median'])<no_capacity_curves:
            EDPlim = damage_model['median'][0]
            bUthd = damage_model['dispersion'][0]
        else:
            EDPlim = damage_model['median'][icc]
            bUthd = damage_model['dispersion'][icc]
        SPO = idealised_capacity[icc]
        if len(SPO) == 3:
            SPO.insert(2,SPO[1])
            SPO.insert(3,SPO[1])
            SPO.insert(-1,SPO[-1])
            SPO.insert(-1,SPO[-1])
            
        [ISDvec, Sdvec] = sdof_utils.from_ISD_to_Sd(capacity_curves,icc)
        RDvec = Sdvec*Gamma
        
        [mc,a,ac,r,mf] = get_spo2ida_parameters(SPO, T, Gamma) # Convert MDoF into SDoF
        [idacm, idacr] = spo2ida_allT(mc,a,ac,r,mf,T,pw,plotflag,filletstyle,N,linew,fontsize) # apply SPO2IDA procedure
        [SaT50, bTSa] = spo2ida_method(idacm, idacr, mf, T, Gamma, g, EDPlim, ISDvec, RDvec, SPO, bUthd, MC)
        
        # Converting the Sa(T1) to Sa(Tav), the common IM
        SaTlogmean_av, bTSa_av = np.log(SaT50)*Sa_ratios[icc], np.array(bTSa)*Sa_ratios[icc]
        allSa.append(SaTlogmean_av)
        allbTSa.append(bTSa_av)

    # Combine the fragility of each building in a single lognormal curve with
    # mean = weighted_mean(means) and std = SRSS(weighted_std(means),weighted_mean(stds))
    logmeans, logstddev = [],[]
    for i in range(0,len(EDPlim)):
        SaLS = [ele[i] for ele in allSa]
        StdSaLS = [ele[i] for ele in allbTSa]
        #log_meanSa.append(np.average(SaLS,weights = w)) # weighted log-mean mean(log(Sa))
        log_m = np.average(SaLS,weights = w)
        #log_stSa.append(np.sqrt(np.sum(w*(np.power((SaLS-log_meanSa[i]),2)+np.power(StdSaLS,2))))) # weighted log-std (dispersion)
        log_s = np.sqrt(np.sum(w*(np.power((SaLS-log_m),2)+np.power(StdSaLS,2))))
        logmeans.append(log_m)
        logstddev.append(log_s)

    fragility_model = {'damage_states': None, 'logmean': None, 'logstddev': None,
    'IMT': None}
    fragility_model['damage_states'] = damage_model['damage_states']
    fragility_model['logmean'] = logmeans
    fragility_model['logstddev'] = logstddev
    fragility_model['IMT'] = 'Sa('+str(Tav)+')'
    
    return fragility_model

def spo2ida_method(idacm, idacr, mf, T, Gamma, g, EDPlim, ISDvec, RDvec, SPO, bUthd, MC):
    
    # Relationship between EDP and RD defined by pushover analysis, if not they are linear
    if len(ISDvec)>2: #this means that there is a given relationship between ISD e roof displacement (only if dfloor has been input)
        [ISDvec,indy]=np.unique(ISDvec,return_index=True);
        RDvec=RDvec[indy];
        
    drlim=np.interp(EDPlim,ISDvec,RDvec)
    print EDPlim, drlim
    dry, du = SPO[0], SPO[-4]
    drlim = np.array(drlim) 
    bUthd = np.array(bUthd)
    
    if bUthd.any>0 and MC==0:
        print 'error: MC must be different from zero'
        os._exit(1)
    tdrlim = drlim
    mlim = np.divide(drlim,dry);
    
    # limiting ductility 
    tdrlim[drlim>du] = du  
    tmlim = np.divide(tdrlim,dry) # tmlim is limited by du
    print "mu(LS) = ", mlim
    
    # Assume lognormal and do some Monte Carlo
    SaT50, bTSa = np.zeros_like(mlim),np.zeros_like(mlim)
    Say = np.power(2*pi,2)*dry/(g*Gamma*np.power(T,2))
    
    if bUthd.all() == float(0):
        for i in range(0,len(tmlim)):
            # find where in ida curves ductility (i) is reached and get corresponding R for all the percentile (j)
            Rcap = [np.interp(tmlim[i],idacm[j],idacr[j]) for j in range(0,len(idacm))]
            SaT50[i] = np.array(Rcap[1])*Say
            bTSa[i] = 0.5*(np.log(np.array(Rcap[0]))-np.log(np.array(Rcap[2])))
    else:
        st = (1./(2.*MC))
        en = (1.-(1./(2.*MC)))
        xp = np.linspace(st,en,MC)
        Sai, Sa = [],[]         
        for i in range(0,len(mlim)):
            Sai.append([])
            Sa.append(np.array([]))
            if bUthd[i]>0:
                EDPsample = stat.lognorm.ppf(xp,bUthd[i],loc=0,scale=EDPlim[i])
                musample = np.interp(EDPsample,ISDvec,RDvec)/dry;
                musample[musample>mf]=mf
                RcapMC = [np.interp(musample,idacm[j],idacr[j]) for j in range(0,len(idacm))]
                # RcapMC[j] with j =0,1,2 are the 3 percentiles corresponding to musample ductilities          
                allSa50 = [ele*Say for ele in RcapMC[1]]
                allbSa50 = (np.log(RcapMC[0])-np.log(RcapMC[2]))/2
                for j in range(0,MC):
                    if allbSa50[j]>0:
                        realisation = stat.lognorm.ppf(xp,allbSa50[j],loc=0,scale=allSa50[j])
                    else:
                        realisation = np.repeat(allSa50[j],MC)
                    Sai[i].append(realisation)
                    
        for i in range(0,len(mlim)):
            if len(Sai[i])>0:
                for j in range(1,len(Sai[i])):
                    Sai[i][j] = np.concatenate((Sai[i][j-1],Sai[i][j]))
                Sa[i] = Sai[i][-1]
                SaT50[i] = np.median(Sa[i])
                bTSa[i] = np.std(np.log(Sa[i]))
            else:
                Rcap = [np.interp(tmlim[i],idacm[j],idacr[j]) for j in range(0,len(idacm))]
                SaT50[i] = np.array(Rcap[1])*Say
                bTSa[i] = 0.5*(np.log(np.array(Rcap[0]))-np.log(np.array(Rcap[2])))
    
    print "median IM = ", SaT50
    print "total dispersion = ", bTSa
    
    return [SaT50,bTSa]
