# -*- coding: utf-8 -*-
"""
Created on Fri Sep  4 17:29:37 2015

@author: chiaracasotto
"""

import numpy as np
import matplotlib.pyplot as plt
from rmtk.vulnerability.common import utils
from scipy import optimize

def calculate_fragility_model_damaged(PDM,Sds,gmrs,IMT,Nstripes,Nrecords,damage_model,T,damping, method):
    
    fragility_model = {}
    no_DS=len(damage_model['damage_states'])
    for iDS in range(1,no_DS):
        fragility_model['iDS' + str(iDS)] = MSA_post_processing(PDM['iDS' + str(iDS)],Sds,gmrs,IMT,Nstripes,Nrecords,damage_model,T,damping, method)

    return fragility_model
    
def MSA_post_processing(PDM,Sds,gmrs,IMT,Nstripes,Nrecords,damage_model,T,damping, method):

    imls = utils.calculate_imls(gmrs, T, damping)
    
    if IMT == 'Sa':
        imls = imls[0]
        IMT = 'Sa('+str(T)+')'
    elif IMT == 'Sd':
        imls = imls[1]
        IMT = 'Sd('+str(T)+')'
    elif IMT == 'PGA':
        imls = imls[2]
            
    stp = np.arange(0,Nrecords*Nstripes,Nrecords)
    iml_bins = [imls[ele] for ele in stp]
    
#    plt.plot(imls[0],Sds['iDS1'],marker='o', linestyle='None')
#    plt.ylim((0,0.5));
    
    no_DS=len(damage_model['damage_states'])
    PDM_msa = np.zeros((Nstripes,no_DS+1))
    for i in range(0,Nstripes):
        PDM_msa[i,:] = np.sum(PDM[Nrecords*i:Nrecords*(i+1)],axis = 0)
    
    no_assets = np.sum(PDM_msa, axis=1, dtype=float)
    cumPDM = np.fliplr(np.cumsum(np.fliplr(PDM_msa), axis=1))
    cumPDM = np.transpose(cumPDM)
    cumPDM = cumPDM/no_assets

    logmeans, logstddev = [], []
    if method == 'least squares':
        for iDS in range(len(damage_model['damage_states'])):
            solution, _ = optimize.leastsq(utils.residual_lognormal_dist,
                                           [0.1, 0.6],
                                           args=(iml_bins, cumPDM[iDS+1]))
            logmeans.append(solution[0])
            logstddev.append(solution[1])

    elif method == 'max likelihood':
        # the imls and the PDM are sorted to be used in the maximum likelihood approach
        # the PDM should be a list of integers in this approach
        I = np.argsort(iml_bins, axis=0)
        iml_bins = np.array(iml_bins)
        iml_bins = iml_bins[I]
        PDM_mle = []
        for iDS in range(len(damage_model['damage_states'])):
            temp = cumPDM[iDS+1][I]*no_assets
            temp2 = temp.astype(int)
            PDM_mle = temp2.tolist()
            solution = utils.mle(PDM_mle,iml_bins,no_assets,1)
            logmeans.append(solution[0])
            logstddev.append(solution[1])
    
    fragility_model = {'damage_states': None, 'logmean': None,
                       'logstddev': None, 'IMT': None}
    fragility_model['damage_states'] = damage_model['damage_states']
    fragility_model['logmean'] = logmeans
    fragility_model['logstddev'] = logstddev
    fragility_model['IMT'] = IMT

    return fragility_model