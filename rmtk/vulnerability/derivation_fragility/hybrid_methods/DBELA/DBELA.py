# -*- coding: utf-8 -*-
import os
import numpy
import math
from scipy import interpolate
from scipy import optimize
import matplotlib.pyplot as plt
from rmtk.vulnerability.common import utils

def calculate_fragility(capacity_curves,gmrs,damage_model,structure_type):
#This function returns a damage probability matrix (PDM) 
    
    no_damage_states = len(damage_model['damage_states'])
    no_gmrs = len(gmrs['time'])
    no_capacity_curves = len(capacity_curves['Sd'])
    PDM = numpy.zeros((no_gmrs,no_damage_states+1))
    for icc in range(no_capacity_curves):
        print str((icc+1)*100/no_capacity_curves) + '%'
        capacity = capacity_curves['Sd'][icc][1:]
        for igmr in range(no_gmrs):
            demand = calculate_demand(gmrs,igmr,capacity_curves,icc,structure_type)
            PDM = compare_capacity_demand(igmr,PDM,capacity,demand)
        
    return PDM

def calculate_demand(gmrs,igmr,capacity_curves,icc,structure_type):
#This function returns the displacement demands

    demand = []
    
    Sd = capacity_curves['Sd'][icc]
    Sdy = capacity_curves['Sdy'][icc]
    height = capacity_curves['heights'][icc]
    period = capacity_curves['periods'][icc]
    ductilities = calculate_ductilities(Sd[1:],Sdy)
    equivalent_dampings = calculate_equivalent_damping(structure_type,ductilities)
    correction_factors = calculate_correction_factors(equivalent_dampings)
    
    time = gmrs['time'][igmr]
    acc = gmrs['acc'][igmr]      
    spectrum = utils.NigamJennings(time,acc,[period],equivalent_dampings[0]) 
    Sde = spectrum['Sd']
    
    for factor in correction_factors:
        demand.append(Sde*factor)
    
    return demand

def calculate_ductilities(Sds,Sdy):

    ductilities = []
    for Sd in Sds:
        ductilities.append(Sd/Sdy)

    return ductilities

def calculate_equivalent_damping(structure_type,ductilities):
#This function calculates the equivalent viscous damping 
	
    equivalent_dampings = []
    if structure_type == 'bare frame' or structure_type == 'infilled frame' :
        for ductility in ductilities:
            equivalent_dampings.append(0.05+0.565*(ductility-1)/(ductility*math.pi))

    return equivalent_dampings
    
def calculate_periods(structure_type,ductilities,height):
    
    periods = []
    
    if structure_type == 'bare frame':
        periods.append(0.070*height)

    if structure_type == 'infilled frame':
        if code == "non-ductile":
            periods.append(0.060*height)
        if code == "ductile":
            periods.append(0.042*height)

    periods.append(periods[0]*math.sqrt(ductilities[1]))
    periods.append(periods[0]*math.sqrt(ductilities[2]))
            
    return periods
    
def calculate_correction_factors(dampings):
#This function calculates the scaling factors to reduce the displacement spectrum
	
    correction_factors=[]
    for damping in dampings:
        correction_factors.append(math.sqrt(10/(5+damping*100)))

    return correction_factors
    
def compare_capacity_demand(igmr,PDM,capacity,demand):
#This function compares the capacity against each demand and allocates the result in the corresponding limit state
        
    no_ls = len(capacity)
    collapse = True
    for ils in range(no_ls):
        if capacity[ils] > demand[ils]:
            PDM[igmr,ils]=PDM[igmr,ils]+1
            collapse = False
            break
    if collapse:
        PDM[igmr,-1]=PDM[igmr,-1]+1
            
    return PDM