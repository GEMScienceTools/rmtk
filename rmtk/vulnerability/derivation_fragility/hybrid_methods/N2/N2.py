# -*- coding: utf-8 -*-
import os
import numpy
import math
from scipy import interpolate
import matplotlib.pyplot as plt
import sys
sys.path.append('../../../common')
import utils

def calculate_fragility(capacity_curves,gmrs,damage_model,damping_model):
    
    no_damage_states = len(damage_model['damage_states'])
    no_gmrs = len(gmrs['time'])
    no_capacity_curves = len(capacity_curves['Sd'])
    PDM = numpy.zeros((no_gmrs,no_damage_states+1))
    

    for icc in range(no_capacity_curves):
        limit_states = utils.define_limit_states(capacity_curves,icc,damage_model)
  
        for igmr in range(no_gmrs):
  #      f = @(parameters) PerformancePoint_BL(GMRs(gmr),CCs(cc),parameters,'M',0);
  #      [solution,fval] = fsolve(f,[5 min(limitStates(:,1))],options);
  #      PDM = allocateDamage(gmr,PDM,solution,limitStates);
  #  end
    
    fragility_model = 0
    
    return fragility_model

def PerformancePoint_BL(gmr,igmr,capacity_curve,icc,damping_model,parameters):

    old_beta = parameters[0]
    old_Sd = parameters[1]
    Sd = capacity_curve['Sd'][icc]
    Sa = capacity_curve['Sa'][icc]
    Sdy = capacity_curve['Sdy'][icc]
    Say = capacity_curve['Say'][icc]
    Sdu = Sd[-1]
    Sau = Sa[-1]
    time = gmr['time'][igmr]
    acc = gmr['acc'][igmr]  
    Ty = 2*math.pi*math.sqrt(Sdy/(Say*9.81))
    minT = Ty*0.5
    maxT = 2*math.pi*math.sqrt(Sdu/(Sau*9.81))
    setT = numpy.linspace(minT,maxT,50)
    
    max_beta = calculate_damping(damping_model,Sdy,Sdu,maxT)    
    spectrum = compute_spectrum(acc,time,setT,old_beta) 
    
	interpolator = interpolate.interp1d(setT,spectrum['Sd'],kind = 'linear')
    demand_Sd_Ty = interpolate(Ty)
    if Sdy>demand_Sd_Ty:
       Sdi = demand_Sd_Ty
       beta = old_beta
    
    else:    
        Sdi,Sai = curveintersect(spectrum['Sd'],spectrum['Sa'],Sd,Sa)
        if isempty(dp):
            if old_beta >= max_beta:
                Sdi = 2*Sdu
                beta = max_beta
            else:
                Sdi = Sdu
                beta_Spec = max_beta
        else:
            errors = Sdi
            beta = Sdi
            for i in range(len(Sdi)):
                beta[i] = calculate_damping(damping_model,Sdy,Sdi[i],Ty)
                errors[i] = abs((old_Sd-Sdi[i])/old_Sd)
            
            Sdi = Sdi[errors.index]
            
            (find(errors==min(errors),1))
            
            beta = beta[]
            
            (find(errors==min(errors),1))
    
    error = abs(old_Sd-dp)+abs(beta-old_beta)
  
    return error
   
def calculate_damping(damping_model,Sdy,Sdu,Sdi,T):
    
    nu = Sdi/Sdy
    
    if damping_model == 'Priesley_et_al2007':
        if nu < 1:
            beta = 0.05
        elif nu < 4:
            beta = (4.9*(nu-1)**2-1.1*(nu-1)**3+5)/100
        elif nu >= 4 and nu < 6.5:
            beta = (14+0.32*(nu-1)+5)/100
        elif nu >= 6.5:
            Teff = (0.89*(sqrt((nu-1)/(1+0.05*(nu-2)))-1)+1)*T
            beta = (19*((0.64*(nu-1)-1)/((0.64*(nu-1))**2))*(Teff/T)**2+5)/100
            
    elif damping_model == 'masonry':
        betai = 5
        betau = 16
        if nu < 1:
            beta = betai
        elif Sdi > Sdu:
            beta = betau
        else:
	        interpolator = interpolate.interp1d([Sdy,Sdu],[betai,betau],kind = 'linear')
            beta = interpolate(Sdi)

    return beta

    
