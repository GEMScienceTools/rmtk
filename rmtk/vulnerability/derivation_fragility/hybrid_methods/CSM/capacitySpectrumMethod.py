# -*- coding: utf-8 -*-
import os
import numpy
import math
from scipy import interpolate
from scipy import optimize
import matplotlib.pyplot as plt
from rmtk.vulnerability.common import utils

def calculate_fragility(capacity_curves,gmrs,damage_model,damping_model,damping):
    
    no_damage_states = len(damage_model['damage_states'])
    no_gmrs = len(gmrs['time'])
    no_capacity_curves = len(capacity_curves['Sd'])
    PDM = numpy.zeros((no_gmrs,no_damage_states+1))
    Sds = numpy.zeros((no_gmrs,no_capacity_curves))
    for icc in range(no_capacity_curves):
        print str((icc+1)*100/no_capacity_curves) + '%'
        for igmr in range(no_gmrs):
            limit_states = utils.define_limit_states(capacity_curves,icc,damage_model)
            damping = optimize.fmin(calculate_performance_point, 0.05, args=(gmrs,igmr,capacity_curves,icc,damping_model,damping), xtol=0.001, ftol=0.001, disp = False, )
            [PDM, ds] = utils.allocate_damage(igmr,PDM,Sdi,limit_states)
            Sds[igmr][icc] = Sdi
    return PDM, Sds

def calculate_performance_point(old_beta,gmrs,igmr,capacity_curves,icc,damping_model,damping):

    global Sdi
    Sd = capacity_curves['Sd'][icc]
    Sa = capacity_curves['Sa'][icc]
    Sdy = capacity_curves['Sdy'][icc]
    Say = capacity_curves['Say'][icc]
    Te = capacity_curves['periods'][icc]
    Sdu = Sd[-1]
    Sau = Sa[-1]
    time = gmrs['time'][igmr]
    acc = gmrs['acc'][igmr]  
    Ty = 2*math.pi*math.sqrt(Sdy/(Say*9.81))
    minT = Ty*0.5
    maxT = Ty*math.sqrt((Sdu/Sdy))
    setT = numpy.linspace(minT,maxT,50)
    
    max_beta = calculate_damping(damping_model,capacity_curves,icc,Sdu,maxT,damping)  
    spectrum = utils.NigamJennings(time,acc,setT,old_beta)
    
    interpolator = interpolate.interp1d(setT,spectrum['Sd'],kind = 'linear')
    demand_Sd_Ty = interpolator(Ty)
    
    Sdi,Sai = utils.find_intersection([Sd,Sa],[spectrum['Sd'],spectrum['Sa']],False)
    if Sdy>demand_Sd_Ty:
        spectrum = utils.NigamJennings(time,acc,[Te],old_beta) 
        Sdi = spectrum['Sd']
        beta = calculate_damping(damping_model,capacity_curves,icc,Sdi,Ty,damping)
        error = 0
        
    else:    
        if len(Sdi) == 0:
            if old_beta >= max_beta:
                Sdi = 2*Sdu
                beta = max_beta
                error = 0
            else:
                Sdi = Sdu
                beta = max_beta
                error = 10
        else:
            errors = numpy.array(Sdi)
            betas = numpy.array(Sdi)
            for i in range(len(Sdi)):
                betas[i] = calculate_damping(damping_model,capacity_curves,icc,Sdi[i],Ty,damping)
                errors[i] = abs(betas[i]-old_beta)
            
            Sdi = Sdi[errors.argsort()[:1]]            
            beta = betas[errors.argsort()[:1]]
    
            error = abs(beta-old_beta)
  
    return error
   

def calculate_damping(damping_model,capacity_curves,icc,Sdi,T,damping):
    
    Sdy = capacity_curves['Sdy'][icc]
    nu = Sdi/Sdy
    
    if damping_model == 'FEMA_2005':
        if nu < 1:
            beta = 0.05
        elif nu < 4:
            beta = (4.9*(nu-1)**2-1.1*(nu-1)**3+5)/100
        elif nu >= 4 and nu < 6.5:
            beta = (14+0.32*(nu-1)+5)/100
        elif nu >= 6.5:
            Teff = (0.89*(math.sqrt((nu-1)/(1+0.05*(nu-2)))-1)+1)*T
            beta = (19*((0.64*(nu-1)-1)/((0.64*(nu-1))**2))*(Teff/T)**2+5)/100
            
    elif damping_model == 'masonry':
        Sd = capacity_curves['Sd'][icc]
        Sdu = Sd[-1]
        betai = 0.05
        betau = 0.16
        if Sdi < Sdy:
            beta = betai
        elif Sdi > Sdu:
            beta = betau
        else:
            interpolator = interpolate.interp1d([Sdy,Sdu],[betai,betau],kind = 'linear')
            beta = interpolator(Sdi)
    
    elif damping_model == 'Iwan_1980':
        beta = 0.05 + 0.0587*(nu-1)**0.371
        
    elif damping_model == 'Gulkan_Sozen_1974':
        beta = 0.05 + 0.2*(1-1/math.sqrt(nu))
        
    elif damping_model == 'Kowalsky_1994':
        Sa = numpy.array(capacity_curves['Sa'][icc])
        Sd = numpy.array(capacity_curves['Sd'][icc])
        Say = capacity_curves['Say'][icc]
        Sdy = capacity_curves['Sdy'][icc]    
        Sa_max = max(Sa)
        Sd_Sa_max = max(Sd[numpy.where(Sa==Sa_max)])
        alpha = (Sa_max-Say)*9.81/(Sd_Sa_max-Sdy)
        beta = 0.05 + 1/math.pi*(1-(1-alpha)/math.sqrt(nu)-alpha*math.sqrt(nu))
        
    elif damping_model == 'Priesley_et_al2007_frames':
        beta = 0.05 + 0.565*(nu-1)/(nu*math.pi)
        
    elif damping_model == 'Priesley_et_al2007_walls':
        beta = 0.05 + 0.444*(nu-1)/(nu*math.pi) 

    elif damping_model == 'Calvi_1999':
        beta = 0.05 + 0.444*(nu-1)/(nu*math.pi) 

    return beta