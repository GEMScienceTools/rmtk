# -*- coding: utf-8 -*-
"""
Created on Mon Sep 22 18:16:12 2014

@author: chiaracasotto
"""

import numpy as np
from rmtk.vulnerability.NSP.spo2ida_method import spo2ida
from rmtk.vulnerability.NSP.simplified_method import simplified_bilinear
from rmtk.vulnerability.NSP.DF_method import DFfragility
from rmtk.vulnerability.NSP.spo2ida_based.spo2ida_allTfunction import spo2ida_allT
from rmtk.vulnerability.NSP.spo2ida_based.get_spo2ida_parameters import get_spo2ida_parameters
from rmtk.vulnerability.common.damage_to_loss import damage_to_loss
import os
cd = os.getcwd()

pw = 1
filletstyle = 3

def vulnerability_process(an_type, T, Gamma, w, EDPlim, dcroof, EDPvec, RDvec, SPO, bUthd, noBlg, g, MC, Sa_ratios, plot_feature, N, Tc, Td):
    plotflag,linew,fontsize,units,iml = plot_feature[0:5]
    LR50s = []
    bLRs = []
    for blg in range(0,noBlg):
        LRs = []
        # Vamvatsikos and Cornell's method
        if np.array(bUthd[blg]).any()>0:
        # If some damage criteria have uncertainty
        # Monte Carlo realisations of damage criteria e derivation of fragility curves 
        # for each sample, mean loss ratios are computed at each IML from all samples 
            for i in range (0,MC):
                dc_sample = np.zeros_like(dcroof[blg])
                EDP_sample = np.zeros(len(dcroof[blg])+1)
                for j in range(0,len(dcroof[blg])):
                    if bUthd[blg][j]>0:
                        EDP_sample[j+1] = np.random.lognormal(np.log(EDPlim[blg][j]),bUthd[blg][j],1)
                        while (EDP_sample[j+1]<=EDP_sample[j]):
                            EDP_sample[j+1] = np.random.lognormal(np.log(EDPlim[blg][j]),bUthd[blg][j],1)
                    else:
                        EDP_sample[j+1] = EDPlim[blg][j]
                    dc_sample[j] = np.interp(EDP_sample[j+1],EDPvec[blg],RDvec[blg]);
                EDP_sample = EDP_sample[1::]
 
                if an_type == 0:
                    [SaT50, bTSa] = simplified_bilinear(T[blg], Gamma[blg], EDP_sample, dc_sample, EDPvec[blg], RDvec[blg], SPO[blg], np.zeros_like(bUthd[blg]), g, MC)
                elif an_type==2: # Dolsek and Fajfar's method
                    [mc,a,ac,r,mf] = get_spo2ida_parameters(SPO[blg], T[blg], Gamma[blg]) # Convert MDoF into SDoF
                    [SaT50,bTSa] = DFfragility(T[blg], Gamma[blg], EDP_sample, dc_sample, EDPvec[blg], RDvec[blg], SPO[blg], np.zeros_like(bUthd[blg]), mc, r, g, Tc, Td, MC)
                else:
                    [mc,a,ac,r,mf] = get_spo2ida_parameters(SPO[blg], T[blg], Gamma[blg])
                    [idacm, idacr] = spo2ida_allT(mc,a,ac,r,mf,T[blg],pw,[0],filletstyle,N,linew,fontsize)
                    [SaT50,bTSa] = spo2ida(idacm, idacr, mf, T[blg], Gamma[blg], g, EDP_sample, dc_sample, EDPvec[blg], RDvec[blg], SPO[blg], np.zeros_like(bUthd[blg]), MC)
                # Conversions
                SaTlogmean_av, bTSa_av = np.log(SaT50)*Sa_ratios[blg], np.array(bTSa)*Sa_ratios[blg]
                LRs.append(damage_to_loss(SaTlogmean_av,bTSa_av,iml,cd+'/NSP/inputs'))
        else: 
        # If any damage criteria have uncertainty
            if an_type == 0:
            # Ruiz-Garcia Miranda's method the uncertainty in the damage criteria is already included in the total dispersion in a simplified way
                [SaT50, bTSa] = simplified_bilinear(T[blg], Gamma[blg], EDPlim[blg], dcroof[blg], EDPvec[blg], RDvec[blg], SPO[blg], bUthd[blg], g, MC)
            elif an_type == 2:
                [mc,a,ac,r,mf] = get_spo2ida_parameters(SPO[blg], T[blg], Gamma[blg]) # Convert MDoF into SDoF
                [SaT50,bTSa] = DFfragility(T[blg], Gamma[blg], EDPlim[blg], dcroof[blg], EDPvec[blg], RDvec[blg], SPO[blg], bUthd[blg], mc, r, g, Tc, Td, MC)
            else:
                [mc,a,ac,r,mf] = get_spo2ida_parameters(SPO[blg], T[blg], Gamma[blg])
                [idacm, idacr] = spo2ida_allT(mc,a,ac,r,mf,T[blg],pw,[0],filletstyle,N,linew,fontsize)
                [SaT50,bTSa] = spo2ida(idacm, idacr, mf, T[blg], Gamma[blg], g, EDPlim[blg], dcroof[blg], EDPvec[blg], RDvec[blg], SPO[blg], bUthd[blg], MC)
            # Conversions
            SaTlogmean_av, bTSa_av = np.log(SaT50)*Sa_ratios[blg], np.array(bTSa)*Sa_ratios[blg]
            LR50 = damage_to_loss(SaTlogmean_av,bTSa_av,iml,cd+'/NSP/inputs')
            LRs.append(LR50)
                    
        # Define Vulnerability curve for each building
        LR50s.append(np.mean(LRs,axis = 0))
        bLRs.append(np.std(LRs, axis = 0))
        
    # Combine the Loss Ratios of each building in a single LR for each iml, 
    # with mean = mean(LRs) and std = std(LRs)
    lr = np.array(LR50s)
    bLRs = np.array(bLRs)
    LR50 = np.average(lr, axis=0, weights=w) # weighted mean
    w2 = np.array([np.repeat(ele,len(iml)) for ele in w])
    bLR = np.sqrt(np.sum(np.multiply(np.power(bLRs,2)+np.power(lr-LR50,2),w2),axis=0))
        
    return [LR50, bLR]