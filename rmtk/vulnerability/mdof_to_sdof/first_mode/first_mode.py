#!/usr/bin/env python
# LICENSE
#
# Copyright (c) 2015, GEM Foundation, Anirudh Rao
#
# The rmtk is free software: you can redistribute
# it and/or modify it under the terms of the GNU Affero General Public
# License as published by the Free Software Foundation, either version
# 3 of the License, or (at your option) any later version.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake. If not, see <http://www.gnu.org/licenses/>
#
# DISCLAIMER
#
# The software rmtk provided herein is released as a prototype
# implementation on behalf of scientists and engineers working within the GEM
# Foundation (Global Earthquake Model).
#
# It is distributed for the purpose of open collaboration and in the
# hope that it will be useful to the scientific, engineering, disaster
# risk and software design communities.
#
# The software is NOT distributed as part of GEM's OpenQuake suite
# (http://www.globalquakemodel.org/openquake) and must be considered as a
# separate entity. The software provided herein is designed and implemented
# by scientific staff. It is not developed to the design standards, nor
# subject to same level of critical review by professional software
# developers, as GEM's OpenQuake software suite.
#
# Feedback and contribution to the software is welcome, and can be
# directed to the risk scientific staff of the GEM Model Facility
# (risk@globalquakemodel.org).
#
# The nrml_converters is therefore distributed WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License for more details.
#
# The GEM Foundation, and the authors of the software, assume no liability for
# use of the software.
"""
Convert MDOF pushover to equivalent SDOF capacity curve using the approach in
ATC-40: Seismic Evaluation and Retrofit of Concrete Buildings
"""

import numpy as np
from rmtk.vulnerability.mdof_to_sdof import sdof_utils

def mdof_to_sdof(capacity_curves, idealised_type):
    periods = capacity_curves['periods']
    ground_heights = capacity_curves['ground_heights']
    regular_heights = capacity_curves['regular_heights']
    gammas = capacity_curves['gamma']
    modal_mass = capacity_curves['modal_mass']
    num_storeys = capacity_curves['no_storeys']
    d_roofs = capacity_curves['droof']
    Vbs = capacity_curves['Vb']
    num_bldgs = len(num_storeys)

    sdof_capacity_curves = {'type': None, 'periods': None, 'heights': None,
        'gamma': None, 'Sdy': None, 'Say': None, 'Sd': None, 'Sa': None}

    sdof_capacity_curves['type'] = 'Sd-Sa'
    if capacity_curves['periods'] != None:
        sdof_capacity_curves['periods'] = capacity_curves['periods']
    if capacity_curves['regular_heights'] != None:
        tot_H = np.array(ground_heights)+np.array(regular_heights)*(np.array(num_storeys)-1);
        sdof_capacity_curves['heights'] = tot_H.tolist()
    if capacity_curves['gamma'] != None:
        sdof_capacity_curves['gamma'] = capacity_curves['gamma']

    Sa = []
    Sd = []

    if capacity_curves['type'] == 'Sd-Sa':
        print "curve refers already to a SDOF oscillator"
        return
    else: #'Vb-droof' or 'Vb-dfloor'
        for bldg in xrange(num_bldgs):
            Sa_bldg = np.array(Vbs[bldg])/modal_mass[bldg]/9.81
            Sd_bldg = np.array(d_roofs[bldg])/gammas[bldg]
            Sa.append(Sa_bldg)
            Sd.append(Sd_bldg)
        sdof_capacity_curves['Sd'] = Sd
        sdof_capacity_curves['Sa'] = Sa

        if idealised_type is not 'none':
            [sdof_capacity_curves, sdof_idealised_capacity] = sdof_utils.idealise_sdof(idealised_type, sdof_capacity_curves)

        else:
            sdof_idealised_capacity = []

        return [sdof_capacity_curves, sdof_idealised_capacity]
        
def define_deformed_shape(capacity_curves, filename):
    
    ISD_vectors, Sd_vectors = [],[]
    for icc in range(len(capacity_curves['no_storeys'])):
        [ISDvec, Sdvec] = sdof_utils.from_ISD_to_Sd(capacity_curves, icc)
        ISD_vectors.append(ISDvec)
        Sd_vectors.append(Sdvec)
        
    sdof_utils.save_deformed_shape(ISD_vectors,Sd_vectors,filename)
    
    return [ISD_vectors, Sd_vectors]