#!/usr/bin/env python
# LICENSE
#
# Copyright (c) 2015, GEM Foundation, Anirudh Rao
#
# The rmtk is free software: you can redistribute
# it and/or modify it under the terms of the GNU Affero General Public
# License as published by the Free Software Foundation, either version
# 3 of the License, or (at your option) any later version.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake. If not, see <http://www.gnu.org/licenses/>
#
# DISCLAIMER
#
# The software rmtk provided herein is released as a prototype
# implementation on behalf of scientists and engineers working within the GEM
# Foundation (Global Earthquake Model).
#
# It is distributed for the purpose of open collaboration and in the
# hope that it will be useful to the scientific, engineering, disaster
# risk and software design communities.
#
# The software is NOT distributed as part of GEM's OpenQuake suite
# (http://www.globalquakemodel.org/openquake) and must be considered as a
# separate entity. The software provided herein is designed and implemented
# by scientific staff. It is not developed to the design standards, nor
# subject to same level of critical review by professional software
# developers, as GEM's OpenQuake software suite.
#
# Feedback and contribution to the software is welcome, and can be
# directed to the risk scientific staff of the GEM Model Facility
# (risk@globalquakemodel.org).
#
# The nrml_converters is therefore distributed WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License for more details.
#
# The GEM Foundation, and the authors of the software, assume no liability for
# use of the software.
"""
Convert MDOF pushover to equivalent SDOF capacity curve using the procedure from
Casarotti, C., & Pinho, R. (2007). An adaptive capacity spectrum method
for assessment of bridges subjected to earthquake action
"""

import numpy as np

def mdof_to_sdof(capacity_curves):
    num_storeys = capacity_curves['no_storeys']
    d_floors = capacity_curves['dfloor']
    Vbs = capacity_curves['Vb']
    weights = [mass * 9.81 for mass in capacity_curves['modal_mass']]
    num_bldgs = len(num_storeys)

    sdof_capacity_curves = {'type': None, 'periods': None, 'heights': None,
        'gamma': None, 'Sdy': None, 'Say': None, 'Sd': None, 'Sa': None}

    sdof_capacity_curves['type'] = 'Sd-Sa'
    if capacity_curves['periods'] != None:
        sdof_capacity_curves['periods'] = capacity_curves['periods']
    if capacity_curves['regular_heights'] != None:
        sdof_capacity_curves['heights'] = capacity_curves['regular_heights']
    if capacity_curves['gamma'] != None:
        sdof_capacity_curves['gamma'] = capacity_curves['gamma']

    Sa = []
    Sd = []

    if capacity_curves['type'] == 'Vb-dfloor':
        for bldg in xrange(num_bldgs):
            Vb = Vbs[bldg]
            num_steps = len(Vb)
            Sa_bldg = []
            Sd_bldg = []

            for step in xrange(num_steps):
                d_step = np.array([d_floors[bldg][floor][step] for floor in range(int(num_storeys[bldg]))])
                Sa_step = Vb[step] / weights[bldg] * sum(np.square(d_step)) / np.square(sum(d_step))
                gamma_step = sum(d_step) / sum(np.square(d_step))
                Sd_step = 1.0/gamma_step
                Sa_bldg.append(Sa_step)
                Sd_bldg.append(Sd_step)
            Sa.append(Sa_bldg)
            Sd.append(Sd_bldg)

        sdof_capacity_curves['Sd'] = Sd
        sdof_capacity_curves['Sa'] = Sa

        return sdof_capacity_curves

    elif capacity_curves['type'] == 'Vb-droof':
        return
    elif capacity_curves['type'] == 'Sd-Sa':
        return
    else:
        return
